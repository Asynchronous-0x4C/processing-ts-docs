import{q as Shader,G as GpuProgram,t as GlProgram,u as TextureMatrix,k as UniformGroup,M as Matrix,v as DefaultBatcher,E as ExtensionType,e as extensions,x as BigPool,y as getGlobalBounds,z as Bounds,F as TexturePool,R as RendererType,H as FilterEffect,I as Sprite,s as Texture,S as STENCIL_MODES,h as CLEAR,w as warn,J as getAttributeInfoFromFormat,K as unsafeEvalSupported,b as Buffer,B as BufferUsage,i as CanvasSource,L as uid$1,j as TextureSource,N as Rectangle,O as SystemRunner,a as EventEmitter,Q as multiplyColors,V as UPDATE_VISIBLE,W as UPDATE_COLOR,X as UPDATE_BLEND,C as Container,Y as Color,Z as getLocalBounds,_ as RenderTexture,P as Point,c as BindGroup,T as Ticker,D as DOMAdapter,$ as VERSION,a0 as deprecation,a1 as v8_0_0,a2 as RendererInitHook}from"./DemoScript.astro_astro_type_script_index_0_lang.DEdM3eRb.js";import{S as State,B as BatchableSprite,c as color32BitToUniform}from"./colorToUniform.Db5An2aa.js";const _Filter=class _Filter2 extends Shader{constructor(options){options={..._Filter2.defaultOptions,...options},super(options),this.enabled=!0,this._state=State.for2d(),this.blendMode=options.blendMode,this.padding=options.padding,typeof options.antialias=="boolean"?this.antialias=options.antialias?"on":"off":this.antialias=options.antialias,this.resolution=options.resolution,this.blendRequired=options.blendRequired,this.clipToViewport=options.clipToViewport,this.addResource("uTexture",0,1)}apply(filterManager,input,output,clearMode){filterManager.applyFilter(this,input,output,clearMode)}get blendMode(){return this._state.blendMode}set blendMode(value){this._state.blendMode=value}static from(options){const{gpu,gl,...rest}=options;let gpuProgram,glProgram;return gpu&&(gpuProgram=GpuProgram.from(gpu)),gl&&(glProgram=GlProgram.from(gl)),new _Filter2({gpuProgram,glProgram,...rest})}};_Filter.defaultOptions={blendMode:"normal",resolution:1,padding:0,antialias:"off",blendRequired:!1,clipToViewport:!0};let Filter=_Filter;var fragment=`in vec2 vMaskCoord;
in vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform sampler2D uMaskTexture;

uniform float uAlpha;
uniform vec4 uMaskClamp;
uniform float uInverse;

out vec4 finalColor;

void main(void)
{
    float clip = step(3.5,
        step(uMaskClamp.x, vMaskCoord.x) +
        step(uMaskClamp.y, vMaskCoord.y) +
        step(vMaskCoord.x, uMaskClamp.z) +
        step(vMaskCoord.y, uMaskClamp.w));

    // TODO look into why this is needed
    float npmAlpha = uAlpha;
    vec4 original = texture(uTexture, vTextureCoord);
    vec4 masky = texture(uMaskTexture, vMaskCoord);
    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);

    float a = alphaMul * masky.r * npmAlpha * clip;

    if (uInverse == 1.0) {
        a = 1.0 - a;
    }

    finalColor = original * a;
}
`,vertex=`in vec2 aPosition;

out vec2 vTextureCoord;
out vec2 vMaskCoord;


uniform vec4 uInputSize;
uniform vec4 uOutputFrame;
uniform vec4 uOutputTexture;
uniform mat3 uFilterMatrix;

vec4 filterVertexPosition(  vec2 aPosition )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;
       
    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

vec2 filterTextureCoord(  vec2 aPosition )
{
    return aPosition * (uOutputFrame.zw * uInputSize.zw);
}

vec2 getFilterCoord( vec2 aPosition )
{
    return  ( uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;
}   

void main(void)
{
    gl_Position = filterVertexPosition(aPosition);
    vTextureCoord = filterTextureCoord(aPosition);
    vMaskCoord = getFilterCoord(aPosition);
}
`,source=`struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

struct MaskUniforms {
  uFilterMatrix:mat3x3<f32>,
  uMaskClamp:vec4<f32>,
  uAlpha:f32,
  uInverse:f32,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uTexture: texture_2d<f32>;
@group(0) @binding(2) var uSampler : sampler;

@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;
@group(1) @binding(1) var uMaskTexture: texture_2d<f32>;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>,
    @location(1) filterUv : vec2<f32>,
};

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;

    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);
}

fn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>
{
  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;
}

fn getSize() -> vec2<f32>
{
  return gfu.uGlobalFrame.zw;
}

@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>,
) -> VSOutput {
  return VSOutput(
   filterVertexPosition(aPosition),
   filterTextureCoord(aPosition),
   getFilterCoord(aPosition)
  );
}

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @location(1) filterUv: vec2<f32>,
  @builtin(position) position: vec4<f32>
) -> @location(0) vec4<f32> {

    var maskClamp = filterUniforms.uMaskClamp;
    var uAlpha = filterUniforms.uAlpha;

    var clip = step(3.5,
      step(maskClamp.x, filterUv.x) +
      step(maskClamp.y, filterUv.y) +
      step(filterUv.x, maskClamp.z) +
      step(filterUv.y, maskClamp.w));

    var mask = textureSample(uMaskTexture, uSampler, filterUv);
    var source = textureSample(uTexture, uSampler, uv);
    var alphaMul = 1.0 - uAlpha * (1.0 - mask.a);

    var a: f32 = alphaMul * mask.r * uAlpha * clip;

    if (filterUniforms.uInverse == 1.0) {
        a = 1.0 - a;
    }

    return source * a;
}
`;class MaskFilter extends Filter{constructor(options){const{sprite,...rest}=options,textureMatrix=new TextureMatrix(sprite.texture),filterUniforms=new UniformGroup({uFilterMatrix:{value:new Matrix,type:"mat3x3<f32>"},uMaskClamp:{value:textureMatrix.uClampFrame,type:"vec4<f32>"},uAlpha:{value:1,type:"f32"},uInverse:{value:options.inverse?1:0,type:"f32"}}),gpuProgram=GpuProgram.from({vertex:{source,entryPoint:"mainVertex"},fragment:{source,entryPoint:"mainFragment"}}),glProgram=GlProgram.from({vertex,fragment,name:"mask-filter"});super({...rest,gpuProgram,glProgram,resources:{filterUniforms,uMaskTexture:sprite.texture.source}}),this.sprite=sprite,this._textureMatrix=textureMatrix}set inverse(value){this.resources.filterUniforms.uniforms.uInverse=value?1:0}get inverse(){return this.resources.filterUniforms.uniforms.uInverse===1}apply(filterManager,input,output,clearMode){this._textureMatrix.texture=this.sprite.texture,filterManager.calculateSpriteMatrix(this.resources.filterUniforms.uniforms.uFilterMatrix,this.sprite).prepend(this._textureMatrix.mapCoord),this.resources.uMaskTexture=this.sprite.texture.source,filterManager.applyFilter(this,input,output,clearMode)}}const _BatcherPipe=class _BatcherPipe2{constructor(renderer,adaptor){this.state=State.for2d(),this._batchersByInstructionSet=Object.create(null),this._activeBatches=Object.create(null),this.renderer=renderer,this._adaptor=adaptor,this._adaptor.init?.(this)}static getBatcher(name){return new this._availableBatchers[name]}buildStart(instructionSet){let batchers=this._batchersByInstructionSet[instructionSet.uid];batchers||(batchers=this._batchersByInstructionSet[instructionSet.uid]=Object.create(null),batchers.default||(batchers.default=new DefaultBatcher({maxTextures:this.renderer.limits.maxBatchableTextures}))),this._activeBatches=batchers,this._activeBatch=this._activeBatches.default;for(const i in this._activeBatches)this._activeBatches[i].begin()}addToBatch(batchableObject,instructionSet){if(this._activeBatch.name!==batchableObject.batcherName){this._activeBatch.break(instructionSet);let batch=this._activeBatches[batchableObject.batcherName];batch||(batch=this._activeBatches[batchableObject.batcherName]=_BatcherPipe2.getBatcher(batchableObject.batcherName),batch.begin()),this._activeBatch=batch}this._activeBatch.add(batchableObject)}break(instructionSet){this._activeBatch.break(instructionSet)}buildEnd(instructionSet){this._activeBatch.break(instructionSet);const batches=this._activeBatches;for(const i in batches){const batch=batches[i],geometry=batch.geometry;geometry.indexBuffer.setDataWithSize(batch.indexBuffer,batch.indexSize,!0),geometry.buffers[0].setDataWithSize(batch.attributeBuffer.float32View,batch.attributeSize,!1)}}upload(instructionSet){const batchers=this._batchersByInstructionSet[instructionSet.uid];for(const i in batchers){const batcher=batchers[i],geometry=batcher.geometry;batcher.dirty&&(batcher.dirty=!1,geometry.buffers[0].update(batcher.attributeSize*4))}}execute(batch){if(batch.action==="startBatch"){const batcher=batch.batcher,geometry=batcher.geometry,shader=batcher.shader;this._adaptor.start(this,geometry,shader)}this._adaptor.execute(this,batch)}destroy(){this.state=null,this.renderer=null,this._adaptor=null;for(const i in this._activeBatches)this._activeBatches[i].destroy();this._activeBatches=null}};_BatcherPipe.extension={type:[ExtensionType.WebGLPipes,ExtensionType.WebGPUPipes,ExtensionType.CanvasPipes],name:"batch"};_BatcherPipe._availableBatchers=Object.create(null);let BatcherPipe=_BatcherPipe;extensions.handleByMap(ExtensionType.Batcher,BatcherPipe._availableBatchers);extensions.add(DefaultBatcher);const textureBit={name:"texture-bit",vertex:{header:`

        struct TextureUniforms {
            uTextureMatrix:mat3x3<f32>,
        }

        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;
        `,main:`
            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;
        `},fragment:{header:`
            @group(2) @binding(0) var uTexture: texture_2d<f32>;
            @group(2) @binding(1) var uSampler: sampler;


        `,main:`
            outColor = textureSample(uTexture, uSampler, vUV);
        `}},textureBitGl={name:"texture-bit",vertex:{header:`
            uniform mat3 uTextureMatrix;
        `,main:`
            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;
        `},fragment:{header:`
        uniform sampler2D uTexture;


        `,main:`
            outColor = texture(uTexture, vUV);
        `}},tempBounds$1=new Bounds;class AlphaMaskEffect extends FilterEffect{constructor(){super(),this.filters=[new MaskFilter({sprite:new Sprite(Texture.EMPTY),inverse:!1,resolution:"inherit",antialias:"inherit"})]}get sprite(){return this.filters[0].sprite}set sprite(value){this.filters[0].sprite=value}get inverse(){return this.filters[0].inverse}set inverse(value){this.filters[0].inverse=value}}class AlphaMaskPipe{constructor(renderer){this._activeMaskStage=[],this._renderer=renderer}push(mask,maskedContainer,instructionSet){const renderer=this._renderer;if(renderer.renderPipes.batch.break(instructionSet),instructionSet.add({renderPipeId:"alphaMask",action:"pushMaskBegin",mask,inverse:maskedContainer._maskOptions.inverse,canBundle:!1,maskedContainer}),mask.inverse=maskedContainer._maskOptions.inverse,mask.renderMaskToTexture){const maskContainer=mask.mask;maskContainer.includeInBuild=!0,maskContainer.collectRenderables(instructionSet,renderer,null),maskContainer.includeInBuild=!1}renderer.renderPipes.batch.break(instructionSet),instructionSet.add({renderPipeId:"alphaMask",action:"pushMaskEnd",mask,maskedContainer,inverse:maskedContainer._maskOptions.inverse,canBundle:!1})}pop(mask,_maskedContainer,instructionSet){this._renderer.renderPipes.batch.break(instructionSet),instructionSet.add({renderPipeId:"alphaMask",action:"popMaskEnd",mask,inverse:_maskedContainer._maskOptions.inverse,canBundle:!1})}execute(instruction){const renderer=this._renderer,renderMask=instruction.mask.renderMaskToTexture;if(instruction.action==="pushMaskBegin"){const filterEffect=BigPool.get(AlphaMaskEffect);if(filterEffect.inverse=instruction.inverse,renderMask){instruction.mask.mask.measurable=!0;const bounds=getGlobalBounds(instruction.mask.mask,!0,tempBounds$1);instruction.mask.mask.measurable=!1,bounds.ceil();const colorTextureSource=renderer.renderTarget.renderTarget.colorTexture.source,filterTexture=TexturePool.getOptimalTexture(bounds.width,bounds.height,colorTextureSource._resolution,colorTextureSource.antialias);renderer.renderTarget.push(filterTexture,!0),renderer.globalUniforms.push({offset:bounds,worldColor:4294967295});const sprite=filterEffect.sprite;sprite.texture=filterTexture,sprite.worldTransform.tx=bounds.minX,sprite.worldTransform.ty=bounds.minY,this._activeMaskStage.push({filterEffect,maskedContainer:instruction.maskedContainer,filterTexture})}else filterEffect.sprite=instruction.mask.mask,this._activeMaskStage.push({filterEffect,maskedContainer:instruction.maskedContainer})}else if(instruction.action==="pushMaskEnd"){const maskData=this._activeMaskStage[this._activeMaskStage.length-1];renderMask&&(renderer.type===RendererType.WEBGL&&renderer.renderTarget.finishRenderPass(),renderer.renderTarget.pop(),renderer.globalUniforms.pop()),renderer.filter.push({renderPipeId:"filter",action:"pushFilter",container:maskData.maskedContainer,filterEffect:maskData.filterEffect,canBundle:!1})}else if(instruction.action==="popMaskEnd"){renderer.filter.pop();const maskData=this._activeMaskStage.pop();renderMask&&TexturePool.returnTexture(maskData.filterTexture),BigPool.return(maskData.filterEffect)}}destroy(){this._renderer=null,this._activeMaskStage=null}}AlphaMaskPipe.extension={type:[ExtensionType.WebGLPipes,ExtensionType.WebGPUPipes,ExtensionType.CanvasPipes],name:"alphaMask"};class ColorMaskPipe{constructor(renderer){this._colorStack=[],this._colorStackIndex=0,this._currentColor=0,this._renderer=renderer}buildStart(){this._colorStack[0]=15,this._colorStackIndex=1,this._currentColor=15}push(mask,_container,instructionSet){this._renderer.renderPipes.batch.break(instructionSet);const colorStack=this._colorStack;colorStack[this._colorStackIndex]=colorStack[this._colorStackIndex-1]&mask.mask;const currentColor=this._colorStack[this._colorStackIndex];currentColor!==this._currentColor&&(this._currentColor=currentColor,instructionSet.add({renderPipeId:"colorMask",colorMask:currentColor,canBundle:!1})),this._colorStackIndex++}pop(_mask,_container,instructionSet){this._renderer.renderPipes.batch.break(instructionSet);const colorStack=this._colorStack;this._colorStackIndex--;const currentColor=colorStack[this._colorStackIndex-1];currentColor!==this._currentColor&&(this._currentColor=currentColor,instructionSet.add({renderPipeId:"colorMask",colorMask:currentColor,canBundle:!1}))}execute(instruction){this._renderer.colorMask.setMask(instruction.colorMask)}destroy(){this._colorStack=null}}ColorMaskPipe.extension={type:[ExtensionType.WebGLPipes,ExtensionType.WebGPUPipes,ExtensionType.CanvasPipes],name:"colorMask"};class StencilMaskPipe{constructor(renderer){this._maskStackHash={},this._maskHash=new WeakMap,this._renderer=renderer}push(mask,_container,instructionSet){var _a;const effect=mask,renderer=this._renderer;renderer.renderPipes.batch.break(instructionSet),renderer.renderPipes.blendMode.setBlendMode(effect.mask,"none",instructionSet),instructionSet.add({renderPipeId:"stencilMask",action:"pushMaskBegin",mask,inverse:_container._maskOptions.inverse,canBundle:!1});const maskContainer=effect.mask;maskContainer.includeInBuild=!0,this._maskHash.has(effect)||this._maskHash.set(effect,{instructionsStart:0,instructionsLength:0});const maskData=this._maskHash.get(effect);maskData.instructionsStart=instructionSet.instructionSize,maskContainer.collectRenderables(instructionSet,renderer,null),maskContainer.includeInBuild=!1,renderer.renderPipes.batch.break(instructionSet),instructionSet.add({renderPipeId:"stencilMask",action:"pushMaskEnd",mask,inverse:_container._maskOptions.inverse,canBundle:!1});const instructionsLength=instructionSet.instructionSize-maskData.instructionsStart-1;maskData.instructionsLength=instructionsLength;const renderTargetUid=renderer.renderTarget.renderTarget.uid;(_a=this._maskStackHash)[renderTargetUid]??(_a[renderTargetUid]=0)}pop(mask,_container,instructionSet){const effect=mask,renderer=this._renderer;renderer.renderPipes.batch.break(instructionSet),renderer.renderPipes.blendMode.setBlendMode(effect.mask,"none",instructionSet),instructionSet.add({renderPipeId:"stencilMask",action:"popMaskBegin",inverse:_container._maskOptions.inverse,canBundle:!1});const maskData=this._maskHash.get(mask);for(let i=0;i<maskData.instructionsLength;i++)instructionSet.instructions[instructionSet.instructionSize++]=instructionSet.instructions[maskData.instructionsStart++];instructionSet.add({renderPipeId:"stencilMask",action:"popMaskEnd",canBundle:!1})}execute(instruction){var _a;const renderer=this._renderer,renderTargetUid=renderer.renderTarget.renderTarget.uid;let maskStackIndex=(_a=this._maskStackHash)[renderTargetUid]??(_a[renderTargetUid]=0);instruction.action==="pushMaskBegin"?(renderer.renderTarget.ensureDepthStencil(),renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_ADD,maskStackIndex),maskStackIndex++,renderer.colorMask.setMask(0)):instruction.action==="pushMaskEnd"?(instruction.inverse?renderer.stencil.setStencilMode(STENCIL_MODES.INVERSE_MASK_ACTIVE,maskStackIndex):renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE,maskStackIndex),renderer.colorMask.setMask(15)):instruction.action==="popMaskBegin"?(renderer.colorMask.setMask(0),maskStackIndex!==0?renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_REMOVE,maskStackIndex):(renderer.renderTarget.clear(null,CLEAR.STENCIL),renderer.stencil.setStencilMode(STENCIL_MODES.DISABLED,maskStackIndex)),maskStackIndex--):instruction.action==="popMaskEnd"&&(instruction.inverse?renderer.stencil.setStencilMode(STENCIL_MODES.INVERSE_MASK_ACTIVE,maskStackIndex):renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE,maskStackIndex),renderer.colorMask.setMask(15)),this._maskStackHash[renderTargetUid]=maskStackIndex}destroy(){this._renderer=null,this._maskStackHash=null,this._maskHash=null}}StencilMaskPipe.extension={type:[ExtensionType.WebGLPipes,ExtensionType.WebGPUPipes,ExtensionType.CanvasPipes],name:"stencilMask"};function ensureAttributes(geometry,extractedData){for(const i in geometry.attributes){const attribute=geometry.attributes[i],attributeData=extractedData[i];attributeData?(attribute.format??(attribute.format=attributeData.format),attribute.offset??(attribute.offset=attributeData.offset),attribute.instance??(attribute.instance=attributeData.instance)):warn(`Attribute ${i} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`)}ensureStartAndStride(geometry)}function ensureStartAndStride(geometry){const{buffers,attributes}=geometry,tempStride={},tempStart={};for(const j in buffers){const buffer=buffers[j];tempStride[buffer.uid]=0,tempStart[buffer.uid]=0}for(const j in attributes){const attribute=attributes[j];tempStride[attribute.buffer.uid]+=getAttributeInfoFromFormat(attribute.format).stride}for(const j in attributes){const attribute=attributes[j];attribute.stride??(attribute.stride=tempStride[attribute.buffer.uid]),attribute.start??(attribute.start=tempStart[attribute.buffer.uid]),tempStart[attribute.buffer.uid]+=getAttributeInfoFromFormat(attribute.format).stride}}const GpuStencilModesToPixi=[];GpuStencilModesToPixi[STENCIL_MODES.NONE]=void 0;GpuStencilModesToPixi[STENCIL_MODES.DISABLED]={stencilWriteMask:0,stencilReadMask:0};GpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_ADD]={stencilFront:{compare:"equal",passOp:"increment-clamp"},stencilBack:{compare:"equal",passOp:"increment-clamp"}};GpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_REMOVE]={stencilFront:{compare:"equal",passOp:"decrement-clamp"},stencilBack:{compare:"equal",passOp:"decrement-clamp"}};GpuStencilModesToPixi[STENCIL_MODES.MASK_ACTIVE]={stencilWriteMask:0,stencilFront:{compare:"equal",passOp:"keep"},stencilBack:{compare:"equal",passOp:"keep"}};GpuStencilModesToPixi[STENCIL_MODES.INVERSE_MASK_ACTIVE]={stencilWriteMask:0,stencilFront:{compare:"not-equal",passOp:"keep"},stencilBack:{compare:"not-equal",passOp:"keep"}};class UboSystem{constructor(adaptor){this._syncFunctionHash=Object.create(null),this._adaptor=adaptor,this._systemCheck()}_systemCheck(){if(!unsafeEvalSupported())throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.")}ensureUniformGroup(uniformGroup){const uniformData=this.getUniformGroupData(uniformGroup);uniformGroup.buffer||(uniformGroup.buffer=new Buffer({data:new Float32Array(uniformData.layout.size/4),usage:BufferUsage.UNIFORM|BufferUsage.COPY_DST}))}getUniformGroupData(uniformGroup){return this._syncFunctionHash[uniformGroup._signature]||this._initUniformGroup(uniformGroup)}_initUniformGroup(uniformGroup){const uniformGroupSignature=uniformGroup._signature;let uniformData=this._syncFunctionHash[uniformGroupSignature];if(!uniformData){const elements=Object.keys(uniformGroup.uniformStructures).map(i=>uniformGroup.uniformStructures[i]),layout=this._adaptor.createUboElements(elements),syncFunction=this._generateUboSync(layout.uboElements);uniformData=this._syncFunctionHash[uniformGroupSignature]={layout,syncFunction}}return this._syncFunctionHash[uniformGroupSignature]}_generateUboSync(uboElements){return this._adaptor.generateUboSync(uboElements)}syncUniformGroup(uniformGroup,data,offset){const uniformGroupData=this.getUniformGroupData(uniformGroup);uniformGroup.buffer||(uniformGroup.buffer=new Buffer({data:new Float32Array(uniformGroupData.layout.size/4),usage:BufferUsage.UNIFORM|BufferUsage.COPY_DST}));let dataInt32=null;return data||(data=uniformGroup.buffer.data,dataInt32=uniformGroup.buffer.dataInt32),offset||(offset=0),uniformGroupData.syncFunction(uniformGroup.uniforms,data,dataInt32,offset),!0}updateUniformGroup(uniformGroup){if(uniformGroup.isStatic&&!uniformGroup._dirtyId)return!1;uniformGroup._dirtyId=0;const synced=this.syncUniformGroup(uniformGroup);return uniformGroup.buffer.update(),synced}destroy(){this._syncFunctionHash=null}}const uniformParsers=[{type:"mat3x3<f32>",test:data=>data.value.a!==void 0,ubo:`
            var matrix = uv[name].toArray(true);
            data[offset] = matrix[0];
            data[offset + 1] = matrix[1];
            data[offset + 2] = matrix[2];
            data[offset + 4] = matrix[3];
            data[offset + 5] = matrix[4];
            data[offset + 6] = matrix[5];
            data[offset + 8] = matrix[6];
            data[offset + 9] = matrix[7];
            data[offset + 10] = matrix[8];
        `,uniform:`
            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));
        `},{type:"vec4<f32>",test:data=>data.type==="vec4<f32>"&&data.size===1&&data.value.width!==void 0,ubo:`
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
            data[offset + 2] = v.width;
            data[offset + 3] = v.height;
        `,uniform:`
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {
                cv[0] = v.x;
                cv[1] = v.y;
                cv[2] = v.width;
                cv[3] = v.height;
                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);
            }
        `},{type:"vec2<f32>",test:data=>data.type==="vec2<f32>"&&data.size===1&&data.value.x!==void 0,ubo:`
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
        `,uniform:`
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y) {
                cv[0] = v.x;
                cv[1] = v.y;
                gl.uniform2f(ud[name].location, v.x, v.y);
            }
        `},{type:"vec4<f32>",test:data=>data.type==="vec4<f32>"&&data.size===1&&data.value.red!==void 0,ubo:`
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
            data[offset + 3] = v.alpha;
        `,uniform:`
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                cv[3] = v.alpha;
                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);
            }
        `},{type:"vec3<f32>",test:data=>data.type==="vec3<f32>"&&data.size===1&&data.value.red!==void 0,ubo:`
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
        `,uniform:`
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);
            }
        `}];function createUboSyncFunction(uboElements,parserCode,arrayGenerationFunction,singleSettersMap){const funcFragments=[`
        var v = null;
        var v2 = null;
        var t = 0;
        var index = 0;
        var name = null;
        var arrayOffset = null;
    `];let prev=0;for(let i=0;i<uboElements.length;i++){const uboElement=uboElements[i],name=uboElement.data.name;let parsed=!1,offset=0;for(let j=0;j<uniformParsers.length;j++)if(uniformParsers[j].test(uboElement.data)){offset=uboElement.offset/4,funcFragments.push(`name = "${name}";`,`offset += ${offset-prev};`,uniformParsers[j][parserCode]||uniformParsers[j].ubo),parsed=!0;break}if(!parsed)if(uboElement.data.size>1)offset=uboElement.offset/4,funcFragments.push(arrayGenerationFunction(uboElement,offset-prev));else{const template=singleSettersMap[uboElement.data.type];offset=uboElement.offset/4,funcFragments.push(`
                    v = uv.${name};
                    offset += ${offset-prev};
                    ${template};
                `)}prev=offset}const fragmentSrc=funcFragments.join(`
`);return new Function("uv","data","dataInt32","offset",fragmentSrc)}function loopMatrix(col,row){return`
        for (let i = 0; i < ${col*row}; i++) {
            data[offset + (((i / ${col})|0) * 4) + (i % ${col})] = v[i];
        }
    `}const uboSyncFunctionsSTD40={f32:`
        data[offset] = v;`,i32:`
        dataInt32[offset] = v;`,"vec2<f32>":`
        data[offset] = v[0];
        data[offset + 1] = v[1];`,"vec3<f32>":`
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];`,"vec4<f32>":`
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];`,"vec2<i32>":`
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];`,"vec3<i32>":`
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];
        dataInt32[offset + 2] = v[2];`,"vec4<i32>":`
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];
        dataInt32[offset + 2] = v[2];
        dataInt32[offset + 3] = v[3];`,"mat2x2<f32>":`
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 4] = v[2];
        data[offset + 5] = v[3];`,"mat3x3<f32>":`
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];
        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];`,"mat4x4<f32>":`
        for (let i = 0; i < 16; i++) {
            data[offset + i] = v[i];
        }`,"mat3x2<f32>":loopMatrix(3,2),"mat4x2<f32>":loopMatrix(4,2),"mat2x3<f32>":loopMatrix(2,3),"mat4x3<f32>":loopMatrix(4,3),"mat2x4<f32>":loopMatrix(2,4),"mat3x4<f32>":loopMatrix(3,4)},uboSyncFunctionsWGSL={...uboSyncFunctionsSTD40,"mat2x2<f32>":`
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];
    `};function calculateProjection(pm,x,y,width,height,flipY){const sign=flipY?1:-1;return pm.identity(),pm.a=1/width*2,pm.d=sign*(1/height*2),pm.tx=-1-x*pm.a,pm.ty=-sign-y*pm.d,pm}const canvasCache=new Map;function getCanvasTexture(canvas,options){if(!canvasCache.has(canvas)){const texture=new Texture({source:new CanvasSource({resource:canvas,...options})}),onDestroy=()=>{canvasCache.get(canvas)===texture&&canvasCache.delete(canvas)};texture.once("destroy",onDestroy),texture.source.once("destroy",onDestroy),canvasCache.set(canvas,texture)}return canvasCache.get(canvas)}function isRenderingToScreen(renderTarget){const resource=renderTarget.colorTexture.source.resource;return globalThis.HTMLCanvasElement&&resource instanceof HTMLCanvasElement&&document.body.contains(resource)}const _RenderTarget=class _RenderTarget2{constructor(descriptor={}){if(this.uid=uid$1("renderTarget"),this.colorTextures=[],this.dirtyId=0,this.isRoot=!1,this._size=new Float32Array(2),this._managedColorTextures=!1,descriptor={..._RenderTarget2.defaultOptions,...descriptor},this.stencil=descriptor.stencil,this.depth=descriptor.depth,this.isRoot=descriptor.isRoot,typeof descriptor.colorTextures=="number"){this._managedColorTextures=!0;for(let i=0;i<descriptor.colorTextures;i++)this.colorTextures.push(new TextureSource({width:descriptor.width,height:descriptor.height,resolution:descriptor.resolution,antialias:descriptor.antialias}))}else{this.colorTextures=[...descriptor.colorTextures.map(texture=>texture.source)];const colorSource=this.colorTexture.source;this.resize(colorSource.width,colorSource.height,colorSource._resolution)}this.colorTexture.source.on("resize",this.onSourceResize,this),(descriptor.depthStencilTexture||this.stencil)&&(descriptor.depthStencilTexture instanceof Texture||descriptor.depthStencilTexture instanceof TextureSource?this.depthStencilTexture=descriptor.depthStencilTexture.source:this.ensureDepthStencilTexture())}get size(){const _size=this._size;return _size[0]=this.pixelWidth,_size[1]=this.pixelHeight,_size}get width(){return this.colorTexture.source.width}get height(){return this.colorTexture.source.height}get pixelWidth(){return this.colorTexture.source.pixelWidth}get pixelHeight(){return this.colorTexture.source.pixelHeight}get resolution(){return this.colorTexture.source._resolution}get colorTexture(){return this.colorTextures[0]}onSourceResize(source2){this.resize(source2.width,source2.height,source2._resolution,!0)}ensureDepthStencilTexture(){this.depthStencilTexture||(this.depthStencilTexture=new TextureSource({width:this.width,height:this.height,resolution:this.resolution,format:"depth24plus-stencil8",autoGenerateMipmaps:!1,antialias:!1,mipLevelCount:1}))}resize(width,height,resolution=this.resolution,skipColorTexture=!1){this.dirtyId++,this.colorTextures.forEach((colorTexture,i)=>{skipColorTexture&&i===0||colorTexture.source.resize(width,height,resolution)}),this.depthStencilTexture&&this.depthStencilTexture.source.resize(width,height,resolution)}destroy(){this.colorTexture.source.off("resize",this.onSourceResize,this),this._managedColorTextures&&this.colorTextures.forEach(texture=>{texture.destroy()}),this.depthStencilTexture&&(this.depthStencilTexture.destroy(),delete this.depthStencilTexture)}};_RenderTarget.defaultOptions={width:0,height:0,resolution:1,colorTextures:1,stencil:!1,depth:!1,antialias:!1,isRoot:!1};let RenderTarget=_RenderTarget;class RenderTargetSystem{constructor(renderer){this.rootViewPort=new Rectangle,this.viewport=new Rectangle,this.onRenderTargetChange=new SystemRunner("onRenderTargetChange"),this.projectionMatrix=new Matrix,this.defaultClearColor=[0,0,0,0],this._renderSurfaceToRenderTargetHash=new Map,this._gpuRenderTargetHash=Object.create(null),this._renderTargetStack=[],this._renderer=renderer,renderer.renderableGC.addManagedHash(this,"_gpuRenderTargetHash")}finishRenderPass(){this.adaptor.finishRenderPass(this.renderTarget)}renderStart({target,clear,clearColor,frame}){this._renderTargetStack.length=0,this.push(target,clear,clearColor,frame),this.rootViewPort.copyFrom(this.viewport),this.rootRenderTarget=this.renderTarget,this.renderingToScreen=isRenderingToScreen(this.rootRenderTarget),this.adaptor.prerender?.(this.rootRenderTarget)}postrender(){this.adaptor.postrender?.(this.rootRenderTarget)}bind(renderSurface,clear=!0,clearColor,frame){const renderTarget=this.getRenderTarget(renderSurface),didChange=this.renderTarget!==renderTarget;this.renderTarget=renderTarget,this.renderSurface=renderSurface;const gpuRenderTarget=this.getGpuRenderTarget(renderTarget);(renderTarget.pixelWidth!==gpuRenderTarget.width||renderTarget.pixelHeight!==gpuRenderTarget.height)&&(this.adaptor.resizeGpuRenderTarget(renderTarget),gpuRenderTarget.width=renderTarget.pixelWidth,gpuRenderTarget.height=renderTarget.pixelHeight);const source2=renderTarget.colorTexture,viewport=this.viewport,pixelWidth=source2.pixelWidth,pixelHeight=source2.pixelHeight;if(!frame&&renderSurface instanceof Texture&&(frame=renderSurface.frame),frame){const resolution=source2._resolution;viewport.x=frame.x*resolution+.5|0,viewport.y=frame.y*resolution+.5|0,viewport.width=frame.width*resolution+.5|0,viewport.height=frame.height*resolution+.5|0}else viewport.x=0,viewport.y=0,viewport.width=pixelWidth,viewport.height=pixelHeight;return calculateProjection(this.projectionMatrix,0,0,viewport.width/source2.resolution,viewport.height/source2.resolution,!renderTarget.isRoot),this.adaptor.startRenderPass(renderTarget,clear,clearColor,viewport),didChange&&this.onRenderTargetChange.emit(renderTarget),renderTarget}clear(target,clear=CLEAR.ALL,clearColor){clear&&(target&&(target=this.getRenderTarget(target)),this.adaptor.clear(target||this.renderTarget,clear,clearColor,this.viewport))}contextChange(){this._gpuRenderTargetHash=Object.create(null)}push(renderSurface,clear=CLEAR.ALL,clearColor,frame){const renderTarget=this.bind(renderSurface,clear,clearColor,frame);return this._renderTargetStack.push({renderTarget,frame}),renderTarget}pop(){this._renderTargetStack.pop();const currentRenderTargetData=this._renderTargetStack[this._renderTargetStack.length-1];this.bind(currentRenderTargetData.renderTarget,!1,null,currentRenderTargetData.frame)}getRenderTarget(renderSurface){return renderSurface.isTexture&&(renderSurface=renderSurface.source),this._renderSurfaceToRenderTargetHash.get(renderSurface)??this._initRenderTarget(renderSurface)}copyToTexture(sourceRenderSurfaceTexture,destinationTexture,originSrc,size,originDest){originSrc.x<0&&(size.width+=originSrc.x,originDest.x-=originSrc.x,originSrc.x=0),originSrc.y<0&&(size.height+=originSrc.y,originDest.y-=originSrc.y,originSrc.y=0);const{pixelWidth,pixelHeight}=sourceRenderSurfaceTexture;return size.width=Math.min(size.width,pixelWidth-originSrc.x),size.height=Math.min(size.height,pixelHeight-originSrc.y),this.adaptor.copyToTexture(sourceRenderSurfaceTexture,destinationTexture,originSrc,size,originDest)}ensureDepthStencil(){this.renderTarget.stencil||(this.renderTarget.stencil=!0,this.adaptor.startRenderPass(this.renderTarget,!1,null,this.viewport))}destroy(){this._renderer=null,this._renderSurfaceToRenderTargetHash.forEach((renderTarget,key)=>{renderTarget!==key&&renderTarget.destroy()}),this._renderSurfaceToRenderTargetHash.clear(),this._gpuRenderTargetHash=Object.create(null)}_initRenderTarget(renderSurface){let renderTarget=null;return CanvasSource.test(renderSurface)&&(renderSurface=getCanvasTexture(renderSurface).source),renderSurface instanceof RenderTarget?renderTarget=renderSurface:renderSurface instanceof TextureSource&&(renderTarget=new RenderTarget({colorTextures:[renderSurface]}),renderSurface.source instanceof CanvasSource&&(renderTarget.isRoot=!0),renderSurface.once("destroy",()=>{renderTarget.destroy(),this._renderSurfaceToRenderTargetHash.delete(renderSurface);const gpuRenderTarget=this._gpuRenderTargetHash[renderTarget.uid];gpuRenderTarget&&(this._gpuRenderTargetHash[renderTarget.uid]=null,this.adaptor.destroyGpuRenderTarget(gpuRenderTarget))})),this._renderSurfaceToRenderTargetHash.set(renderSurface,renderTarget),renderTarget}getGpuRenderTarget(renderTarget){return this._gpuRenderTargetHash[renderTarget.uid]||(this._gpuRenderTargetHash[renderTarget.uid]=this.adaptor.initGpuRenderTarget(renderTarget))}resetState(){this.renderTarget=null,this.renderSurface=null}}class BufferResource extends EventEmitter{constructor({buffer,offset,size}){super(),this.uid=uid$1("buffer"),this._resourceType="bufferResource",this._touched=0,this._resourceId=uid$1("resource"),this._bufferResource=!0,this.destroyed=!1,this.buffer=buffer,this.offset=offset|0,this.size=size,this.buffer.on("change",this.onBufferChange,this)}onBufferChange(){this._resourceId=uid$1("resource"),this.emit("change",this)}destroy(destroyBuffer=!1){this.destroyed=!0,destroyBuffer&&this.buffer.destroy(),this.emit("change",this),this.buffer=null}}class CustomRenderPipe{constructor(renderer){this._renderer=renderer}updateRenderable(){}destroyRenderable(){}validateRenderable(){return!1}addRenderable(container,instructionSet){this._renderer.renderPipes.batch.break(instructionSet),instructionSet.add(container)}execute(container){container.isRenderable&&container.render(this._renderer)}destroy(){this._renderer=null}}CustomRenderPipe.extension={type:[ExtensionType.WebGLPipes,ExtensionType.WebGPUPipes,ExtensionType.CanvasPipes],name:"customRender"};function executeInstructions(renderGroup,renderer){const instructionSet=renderGroup.instructionSet,instructions=instructionSet.instructions;for(let i=0;i<instructionSet.instructionSize;i++){const instruction=instructions[i];renderer[instruction.renderPipeId].execute(instruction)}}const tempMatrix$1=new Matrix;class RenderGroupPipe{constructor(renderer){this._renderer=renderer}addRenderGroup(renderGroup,instructionSet){renderGroup.isCachedAsTexture?this._addRenderableCacheAsTexture(renderGroup,instructionSet):this._addRenderableDirect(renderGroup,instructionSet)}execute(renderGroup){renderGroup.isRenderable&&(renderGroup.isCachedAsTexture?this._executeCacheAsTexture(renderGroup):this._executeDirect(renderGroup))}destroy(){this._renderer=null}_addRenderableDirect(renderGroup,instructionSet){this._renderer.renderPipes.batch.break(instructionSet),renderGroup._batchableRenderGroup&&(BigPool.return(renderGroup._batchableRenderGroup),renderGroup._batchableRenderGroup=null),instructionSet.add(renderGroup)}_addRenderableCacheAsTexture(renderGroup,instructionSet){const batchableRenderGroup=renderGroup._batchableRenderGroup??(renderGroup._batchableRenderGroup=BigPool.get(BatchableSprite));batchableRenderGroup.renderable=renderGroup.root,batchableRenderGroup.transform=renderGroup.root.relativeGroupTransform,batchableRenderGroup.texture=renderGroup.texture,batchableRenderGroup.bounds=renderGroup._textureBounds,instructionSet.add(renderGroup),this._renderer.renderPipes.batch.addToBatch(batchableRenderGroup,instructionSet)}_executeCacheAsTexture(renderGroup){if(renderGroup.textureNeedsUpdate){renderGroup.textureNeedsUpdate=!1;const worldTransformMatrix=tempMatrix$1.identity().translate(-renderGroup._textureBounds.x,-renderGroup._textureBounds.y);this._renderer.renderTarget.push(renderGroup.texture,!0,null,renderGroup.texture.frame),this._renderer.globalUniforms.push({worldTransformMatrix,worldColor:4294967295}),executeInstructions(renderGroup,this._renderer.renderPipes),this._renderer.renderTarget.finishRenderPass(),this._renderer.renderTarget.pop(),this._renderer.globalUniforms.pop()}renderGroup._batchableRenderGroup._batcher.updateElement(renderGroup._batchableRenderGroup),renderGroup._batchableRenderGroup._batcher.geometry.buffers[0].update()}_executeDirect(renderGroup){this._renderer.globalUniforms.push({worldTransformMatrix:renderGroup.inverseParentTextureTransform,worldColor:renderGroup.worldColorAlpha}),executeInstructions(renderGroup,this._renderer.renderPipes),this._renderer.globalUniforms.pop()}}RenderGroupPipe.extension={type:[ExtensionType.WebGLPipes,ExtensionType.WebGPUPipes,ExtensionType.CanvasPipes],name:"renderGroup"};function clearList(list,index){index||(index=0);for(let j=index;j<list.length&&list[j];j++)list[j]=null}const tempContainer=new Container,UPDATE_BLEND_COLOR_VISIBLE=UPDATE_VISIBLE|UPDATE_COLOR|UPDATE_BLEND;function updateRenderGroupTransforms(renderGroup,updateChildRenderGroups=!1){updateRenderGroupTransform(renderGroup);const childrenToUpdate=renderGroup.childrenToUpdate,updateTick=renderGroup.updateTick++;for(const j in childrenToUpdate){const renderGroupDepth=Number(j),childrenAtDepth=childrenToUpdate[j],list=childrenAtDepth.list,index=childrenAtDepth.index;for(let i=0;i<index;i++){const child=list[i];child.parentRenderGroup===renderGroup&&child.relativeRenderGroupDepth===renderGroupDepth&&updateTransformAndChildren(child,updateTick,0)}clearList(list,index),childrenAtDepth.index=0}if(updateChildRenderGroups)for(let i=0;i<renderGroup.renderGroupChildren.length;i++)updateRenderGroupTransforms(renderGroup.renderGroupChildren[i],updateChildRenderGroups)}function updateRenderGroupTransform(renderGroup){const root=renderGroup.root;let worldAlpha;if(renderGroup.renderGroupParent){const renderGroupParent=renderGroup.renderGroupParent;renderGroup.worldTransform.appendFrom(root.relativeGroupTransform,renderGroupParent.worldTransform),renderGroup.worldColor=multiplyColors(root.groupColor,renderGroupParent.worldColor),worldAlpha=root.groupAlpha*renderGroupParent.worldAlpha}else renderGroup.worldTransform.copyFrom(root.localTransform),renderGroup.worldColor=root.localColor,worldAlpha=root.localAlpha;worldAlpha=worldAlpha<0?0:worldAlpha>1?1:worldAlpha,renderGroup.worldAlpha=worldAlpha,renderGroup.worldColorAlpha=renderGroup.worldColor+((worldAlpha*255|0)<<24)}function updateTransformAndChildren(container,updateTick,updateFlags){if(updateTick===container.updateTick)return;container.updateTick=updateTick,container.didChange=!1;const localTransform=container.localTransform;container.updateLocalTransform();const parent=container.parent;if(parent&&!parent.renderGroup?(updateFlags|=container._updateFlags,container.relativeGroupTransform.appendFrom(localTransform,parent.relativeGroupTransform),updateFlags&UPDATE_BLEND_COLOR_VISIBLE&&updateColorBlendVisibility(container,parent,updateFlags)):(updateFlags=container._updateFlags,container.relativeGroupTransform.copyFrom(localTransform),updateFlags&UPDATE_BLEND_COLOR_VISIBLE&&updateColorBlendVisibility(container,tempContainer,updateFlags)),!container.renderGroup){const children=container.children,length=children.length;for(let i=0;i<length;i++)updateTransformAndChildren(children[i],updateTick,updateFlags);const renderGroup=container.parentRenderGroup,renderable=container;renderable.renderPipeId&&!renderGroup.structureDidChange&&renderGroup.updateRenderable(renderable)}}function updateColorBlendVisibility(container,parent,updateFlags){if(updateFlags&UPDATE_COLOR){container.groupColor=multiplyColors(container.localColor,parent.groupColor);let groupAlpha=container.localAlpha*parent.groupAlpha;groupAlpha=groupAlpha<0?0:groupAlpha>1?1:groupAlpha,container.groupAlpha=groupAlpha,container.groupColorAlpha=container.groupColor+((groupAlpha*255|0)<<24)}updateFlags&UPDATE_BLEND&&(container.groupBlendMode=container.localBlendMode==="inherit"?parent.groupBlendMode:container.localBlendMode),updateFlags&UPDATE_VISIBLE&&(container.globalDisplayStatus=container.localDisplayStatus&parent.globalDisplayStatus),container._updateFlags=0}function validateRenderables(renderGroup,renderPipes){const{list,index}=renderGroup.childrenRenderablesToUpdate;let rebuildRequired=!1;for(let i=0;i<index;i++){const container=list[i];if(rebuildRequired=renderPipes[container.renderPipeId].validateRenderable(container),rebuildRequired)break}return renderGroup.structureDidChange=rebuildRequired,rebuildRequired}const tempMatrix=new Matrix;class RenderGroupSystem{constructor(renderer){this._renderer=renderer}render({container,transform}){const parent=container.parent,renderGroupParent=container.renderGroup.renderGroupParent;container.parent=null,container.renderGroup.renderGroupParent=null;const renderer=this._renderer;let originalLocalTransform=tempMatrix;transform&&(originalLocalTransform=originalLocalTransform.copyFrom(container.renderGroup.localTransform),container.renderGroup.localTransform.copyFrom(transform));const renderPipes=renderer.renderPipes;this._updateCachedRenderGroups(container.renderGroup,null),this._updateRenderGroups(container.renderGroup),renderer.globalUniforms.start({worldTransformMatrix:transform?container.renderGroup.localTransform:container.renderGroup.worldTransform,worldColor:container.renderGroup.worldColorAlpha}),executeInstructions(container.renderGroup,renderPipes),renderPipes.uniformBatch&&renderPipes.uniformBatch.renderEnd(),transform&&container.renderGroup.localTransform.copyFrom(originalLocalTransform),container.parent=parent,container.renderGroup.renderGroupParent=renderGroupParent}destroy(){this._renderer=null}_updateCachedRenderGroups(renderGroup,closestCacheAsTexture){if(renderGroup.isCachedAsTexture){if(!renderGroup.updateCacheTexture)return;closestCacheAsTexture=renderGroup}renderGroup._parentCacheAsTextureRenderGroup=closestCacheAsTexture;for(let i=renderGroup.renderGroupChildren.length-1;i>=0;i--)this._updateCachedRenderGroups(renderGroup.renderGroupChildren[i],closestCacheAsTexture);if(renderGroup.invalidateMatrices(),renderGroup.isCachedAsTexture){if(renderGroup.textureNeedsUpdate){const bounds=renderGroup.root.getLocalBounds();bounds.ceil();const lastTexture=renderGroup.texture;renderGroup.texture&&TexturePool.returnTexture(renderGroup.texture);const renderer=this._renderer,resolution=renderGroup.textureOptions.resolution||renderer.view.resolution,antialias=renderGroup.textureOptions.antialias??renderer.view.antialias;renderGroup.texture=TexturePool.getOptimalTexture(bounds.width,bounds.height,resolution,antialias),renderGroup._textureBounds||(renderGroup._textureBounds=new Bounds),renderGroup._textureBounds.copyFrom(bounds),lastTexture!==renderGroup.texture&&renderGroup.renderGroupParent&&(renderGroup.renderGroupParent.structureDidChange=!0)}}else renderGroup.texture&&(TexturePool.returnTexture(renderGroup.texture),renderGroup.texture=null)}_updateRenderGroups(renderGroup){const renderer=this._renderer,renderPipes=renderer.renderPipes;if(renderGroup.runOnRender(renderer),renderGroup.instructionSet.renderPipes=renderPipes,renderGroup.structureDidChange?clearList(renderGroup.childrenRenderablesToUpdate.list,0):validateRenderables(renderGroup,renderPipes),updateRenderGroupTransforms(renderGroup),renderGroup.structureDidChange?(renderGroup.structureDidChange=!1,this._buildInstructions(renderGroup,renderer)):this._updateRenderables(renderGroup),renderGroup.childrenRenderablesToUpdate.index=0,renderer.renderPipes.batch.upload(renderGroup.instructionSet),!(renderGroup.isCachedAsTexture&&!renderGroup.textureNeedsUpdate))for(let i=0;i<renderGroup.renderGroupChildren.length;i++)this._updateRenderGroups(renderGroup.renderGroupChildren[i])}_updateRenderables(renderGroup){const{list,index}=renderGroup.childrenRenderablesToUpdate;for(let i=0;i<index;i++){const container=list[i];container.didViewUpdate&&renderGroup.updateRenderable(container)}clearList(list,index)}_buildInstructions(renderGroup,rendererOrPipes){const root=renderGroup.root,instructionSet=renderGroup.instructionSet;instructionSet.reset();const renderer=rendererOrPipes.renderPipes?rendererOrPipes:rendererOrPipes.batch.renderer,renderPipes=renderer.renderPipes;renderPipes.batch.buildStart(instructionSet),renderPipes.blendMode.buildStart(),renderPipes.colorMask.buildStart(),root.sortableChildren&&root.sortChildren(),root.collectRenderablesWithEffects(instructionSet,renderer,null),renderPipes.batch.buildEnd(instructionSet),renderPipes.blendMode.buildEnd(instructionSet)}}RenderGroupSystem.extension={type:[ExtensionType.WebGLSystem,ExtensionType.WebGPUSystem,ExtensionType.CanvasSystem],name:"renderGroup"};class SpritePipe{constructor(renderer){this._renderer=renderer}addRenderable(sprite,instructionSet){const gpuSprite=this._getGpuSprite(sprite);sprite.didViewUpdate&&this._updateBatchableSprite(sprite,gpuSprite),this._renderer.renderPipes.batch.addToBatch(gpuSprite,instructionSet)}updateRenderable(sprite){const gpuSprite=this._getGpuSprite(sprite);sprite.didViewUpdate&&this._updateBatchableSprite(sprite,gpuSprite),gpuSprite._batcher.updateElement(gpuSprite)}validateRenderable(sprite){const gpuSprite=this._getGpuSprite(sprite);return!gpuSprite._batcher.checkAndUpdateTexture(gpuSprite,sprite._texture)}_updateBatchableSprite(sprite,batchableSprite){batchableSprite.bounds=sprite.visualBounds,batchableSprite.texture=sprite._texture}_getGpuSprite(sprite){return sprite._gpuData[this._renderer.uid]||this._initGPUSprite(sprite)}_initGPUSprite(sprite){const batchableSprite=new BatchableSprite;return batchableSprite.renderable=sprite,batchableSprite.transform=sprite.groupTransform,batchableSprite.texture=sprite._texture,batchableSprite.bounds=sprite.visualBounds,batchableSprite.roundPixels=this._renderer._roundPixels|sprite._roundPixels,sprite._gpuData[this._renderer.uid]=batchableSprite,batchableSprite}destroy(){this._renderer=null}}SpritePipe.extension={type:[ExtensionType.WebGLPipes,ExtensionType.WebGPUPipes,ExtensionType.CanvasPipes],name:"sprite"};const _BackgroundSystem=class _BackgroundSystem2{constructor(){this.clearBeforeRender=!0,this._backgroundColor=new Color(0),this.color=this._backgroundColor,this.alpha=1}init(options){options={..._BackgroundSystem2.defaultOptions,...options},this.clearBeforeRender=options.clearBeforeRender,this.color=options.background||options.backgroundColor||this._backgroundColor,this.alpha=options.backgroundAlpha,this._backgroundColor.setAlpha(options.backgroundAlpha)}get color(){return this._backgroundColor}set color(value){this._backgroundColor.setValue(value)}get alpha(){return this._backgroundColor.alpha}set alpha(value){this._backgroundColor.setAlpha(value)}get colorRgba(){return this._backgroundColor.toArray()}destroy(){}};_BackgroundSystem.extension={type:[ExtensionType.WebGLSystem,ExtensionType.WebGPUSystem,ExtensionType.CanvasSystem],name:"background",priority:0};_BackgroundSystem.defaultOptions={backgroundAlpha:1,backgroundColor:0,clearBeforeRender:!0};let BackgroundSystem=_BackgroundSystem;const BLEND_MODE_FILTERS={};extensions.handle(ExtensionType.BlendMode,value=>{if(!value.name)throw new Error("BlendMode extension must have a name property");BLEND_MODE_FILTERS[value.name]=value.ref},value=>{delete BLEND_MODE_FILTERS[value.name]});class BlendModePipe{constructor(renderer){this._isAdvanced=!1,this._filterHash=Object.create(null),this._renderer=renderer,this._renderer.runners.prerender.add(this)}prerender(){this._activeBlendMode="normal",this._isAdvanced=!1}setBlendMode(renderable,blendMode,instructionSet){if(this._activeBlendMode===blendMode){this._isAdvanced&&this._renderableList.push(renderable);return}this._activeBlendMode=blendMode,this._isAdvanced&&this._endAdvancedBlendMode(instructionSet),this._isAdvanced=!!BLEND_MODE_FILTERS[blendMode],this._isAdvanced&&(this._beginAdvancedBlendMode(instructionSet),this._renderableList.push(renderable))}_beginAdvancedBlendMode(instructionSet){this._renderer.renderPipes.batch.break(instructionSet);const blendMode=this._activeBlendMode;if(!BLEND_MODE_FILTERS[blendMode]){warn(`Unable to assign BlendMode: '${blendMode}'. You may want to include: import 'pixi.js/advanced-blend-modes'`);return}let filterEffect=this._filterHash[blendMode];filterEffect||(filterEffect=this._filterHash[blendMode]=new FilterEffect,filterEffect.filters=[new BLEND_MODE_FILTERS[blendMode]]);const instruction={renderPipeId:"filter",action:"pushFilter",renderables:[],filterEffect,canBundle:!1};this._renderableList=instruction.renderables,instructionSet.add(instruction)}_endAdvancedBlendMode(instructionSet){this._renderableList=null,this._renderer.renderPipes.batch.break(instructionSet),instructionSet.add({renderPipeId:"filter",action:"popFilter",canBundle:!1})}buildStart(){this._isAdvanced=!1}buildEnd(instructionSet){this._isAdvanced&&this._endAdvancedBlendMode(instructionSet)}destroy(){this._renderer=null,this._renderableList=null;for(const i in this._filterHash)this._filterHash[i].destroy();this._filterHash=null}}BlendModePipe.extension={type:[ExtensionType.WebGLPipes,ExtensionType.WebGPUPipes,ExtensionType.CanvasPipes],name:"blendMode"};const imageTypes={png:"image/png",jpg:"image/jpeg",webp:"image/webp"},_ExtractSystem=class _ExtractSystem2{constructor(renderer){this._renderer=renderer}_normalizeOptions(options,defaults={}){return options instanceof Container||options instanceof Texture?{target:options,...defaults}:{...defaults,...options}}async image(options){const image=new Image;return image.src=await this.base64(options),image}async base64(options){options=this._normalizeOptions(options,_ExtractSystem2.defaultImageOptions);const{format,quality}=options,canvas=this.canvas(options);if(canvas.toBlob!==void 0)return new Promise((resolve,reject)=>{canvas.toBlob(blob=>{if(!blob){reject(new Error("ICanvas.toBlob failed!"));return}const reader=new FileReader;reader.onload=()=>resolve(reader.result),reader.onerror=reject,reader.readAsDataURL(blob)},imageTypes[format],quality)});if(canvas.toDataURL!==void 0)return canvas.toDataURL(imageTypes[format],quality);if(canvas.convertToBlob!==void 0){const blob=await canvas.convertToBlob({type:imageTypes[format],quality});return new Promise((resolve,reject)=>{const reader=new FileReader;reader.onload=()=>resolve(reader.result),reader.onerror=reject,reader.readAsDataURL(blob)})}throw new Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented")}canvas(options){options=this._normalizeOptions(options);const target=options.target,renderer=this._renderer;if(target instanceof Texture)return renderer.texture.generateCanvas(target);const texture=renderer.textureGenerator.generateTexture(options),canvas=renderer.texture.generateCanvas(texture);return texture.destroy(!0),canvas}pixels(options){options=this._normalizeOptions(options);const target=options.target,renderer=this._renderer,texture=target instanceof Texture?target:renderer.textureGenerator.generateTexture(options),pixelInfo=renderer.texture.getPixels(texture);return target instanceof Container&&texture.destroy(!0),pixelInfo}texture(options){return options=this._normalizeOptions(options),options.target instanceof Texture?options.target:this._renderer.textureGenerator.generateTexture(options)}download(options){options=this._normalizeOptions(options);const canvas=this.canvas(options),link=document.createElement("a");link.download=options.filename??"image.png",link.href=canvas.toDataURL("image/png"),document.body.appendChild(link),link.click(),document.body.removeChild(link)}log(options){const width=options.width??200;options=this._normalizeOptions(options);const canvas=this.canvas(options),base64=canvas.toDataURL();console.log(`[Pixi Texture] ${canvas.width}px ${canvas.height}px`);const style=["font-size: 1px;",`padding: ${width}px 300px;`,`background: url(${base64}) no-repeat;`,"background-size: contain;"].join(" ");console.log("%c ",style)}destroy(){this._renderer=null}};_ExtractSystem.extension={type:[ExtensionType.WebGLSystem,ExtensionType.WebGPUSystem],name:"extract"};_ExtractSystem.defaultImageOptions={format:"png",quality:1};let ExtractSystem=_ExtractSystem;const tempRect=new Rectangle,tempBounds=new Bounds,noColor=[0,0,0,0];class GenerateTextureSystem{constructor(renderer){this._renderer=renderer}generateTexture(options){options instanceof Container&&(options={target:options,frame:void 0,textureSourceOptions:{},resolution:void 0});const resolution=options.resolution||this._renderer.resolution,antialias=options.antialias||this._renderer.view.antialias,container=options.target;let clearColor=options.clearColor;clearColor?clearColor=Array.isArray(clearColor)&&clearColor.length===4?clearColor:Color.shared.setValue(clearColor).toArray():clearColor=noColor;const region=options.frame?.copyTo(tempRect)||getLocalBounds(container,tempBounds).rectangle;region.width=Math.max(region.width,1/resolution)|0,region.height=Math.max(region.height,1/resolution)|0;const target=RenderTexture.create({...options.textureSourceOptions,width:region.width,height:region.height,resolution,antialias}),transform=Matrix.shared.translate(-region.x,-region.y);return this._renderer.render({container,transform,target,clearColor}),target.source.updateMipmaps(),target}destroy(){this._renderer=null}}GenerateTextureSystem.extension={type:[ExtensionType.WebGLSystem,ExtensionType.WebGPUSystem],name:"textureGenerator"};class GlobalUniformSystem{constructor(renderer){this._stackIndex=0,this._globalUniformDataStack=[],this._uniformsPool=[],this._activeUniforms=[],this._bindGroupPool=[],this._activeBindGroups=[],this._renderer=renderer}reset(){this._stackIndex=0;for(let i=0;i<this._activeUniforms.length;i++)this._uniformsPool.push(this._activeUniforms[i]);for(let i=0;i<this._activeBindGroups.length;i++)this._bindGroupPool.push(this._activeBindGroups[i]);this._activeUniforms.length=0,this._activeBindGroups.length=0}start(options){this.reset(),this.push(options)}bind({size,projectionMatrix,worldTransformMatrix,worldColor,offset}){const renderTarget=this._renderer.renderTarget.renderTarget,currentGlobalUniformData=this._stackIndex?this._globalUniformDataStack[this._stackIndex-1]:{worldTransformMatrix:new Matrix,worldColor:4294967295,offset:new Point},globalUniformData={projectionMatrix:projectionMatrix||this._renderer.renderTarget.projectionMatrix,resolution:size||renderTarget.size,worldTransformMatrix:worldTransformMatrix||currentGlobalUniformData.worldTransformMatrix,worldColor:worldColor||currentGlobalUniformData.worldColor,offset:offset||currentGlobalUniformData.offset,bindGroup:null},uniformGroup=this._uniformsPool.pop()||this._createUniforms();this._activeUniforms.push(uniformGroup);const uniforms=uniformGroup.uniforms;uniforms.uProjectionMatrix=globalUniformData.projectionMatrix,uniforms.uResolution=globalUniformData.resolution,uniforms.uWorldTransformMatrix.copyFrom(globalUniformData.worldTransformMatrix),uniforms.uWorldTransformMatrix.tx-=globalUniformData.offset.x,uniforms.uWorldTransformMatrix.ty-=globalUniformData.offset.y,color32BitToUniform(globalUniformData.worldColor,uniforms.uWorldColorAlpha,0),uniformGroup.update();let bindGroup;this._renderer.renderPipes.uniformBatch?bindGroup=this._renderer.renderPipes.uniformBatch.getUniformBindGroup(uniformGroup,!1):(bindGroup=this._bindGroupPool.pop()||new BindGroup,this._activeBindGroups.push(bindGroup),bindGroup.setResource(uniformGroup,0)),globalUniformData.bindGroup=bindGroup,this._currentGlobalUniformData=globalUniformData}push(options){this.bind(options),this._globalUniformDataStack[this._stackIndex++]=this._currentGlobalUniformData}pop(){this._currentGlobalUniformData=this._globalUniformDataStack[--this._stackIndex-1],this._renderer.type===RendererType.WEBGL&&this._currentGlobalUniformData.bindGroup.resources[0].update()}get bindGroup(){return this._currentGlobalUniformData.bindGroup}get globalUniformData(){return this._currentGlobalUniformData}get uniformGroup(){return this._currentGlobalUniformData.bindGroup.resources[0]}_createUniforms(){return new UniformGroup({uProjectionMatrix:{value:new Matrix,type:"mat3x3<f32>"},uWorldTransformMatrix:{value:new Matrix,type:"mat3x3<f32>"},uWorldColorAlpha:{value:new Float32Array(4),type:"vec4<f32>"},uResolution:{value:[0,0],type:"vec2<f32>"}},{isStatic:!0})}destroy(){this._renderer=null}}GlobalUniformSystem.extension={type:[ExtensionType.WebGLSystem,ExtensionType.WebGPUSystem,ExtensionType.CanvasSystem],name:"globalUniforms"};let uid=1;class SchedulerSystem{constructor(){this._tasks=[],this._offset=0}init(){Ticker.system.add(this._update,this)}repeat(func,duration,useOffset=!0){const id=uid++;let offset=0;return useOffset&&(this._offset+=1e3,offset=this._offset),this._tasks.push({func,duration,start:performance.now(),offset,last:performance.now(),repeat:!0,id}),id}cancel(id){for(let i=0;i<this._tasks.length;i++)if(this._tasks[i].id===id){this._tasks.splice(i,1);return}}_update(){const now=performance.now();for(let i=0;i<this._tasks.length;i++){const task=this._tasks[i];if(now-task.offset-task.last>=task.duration){const elapsed=now-task.start;task.func(elapsed),task.last=now}}}destroy(){Ticker.system.remove(this._update,this),this._tasks.length=0}}SchedulerSystem.extension={type:[ExtensionType.WebGLSystem,ExtensionType.WebGPUSystem,ExtensionType.CanvasSystem],name:"scheduler",priority:0};let saidHello=!1;function sayHello(type){if(!saidHello){if(DOMAdapter.get().getNavigator().userAgent.toLowerCase().indexOf("chrome")>-1){const args=[`%c  %c  %c  %c  %c PixiJS %c v${VERSION} (${type}) http://www.pixijs.com/

`,"background: #E72264; padding:5px 0;","background: #6CA2EA; padding:5px 0;","background: #B5D33D; padding:5px 0;","background: #FED23F; padding:5px 0;","color: #FFFFFF; background: #E72264; padding:5px 0;","color: #E72264; background: #FFFFFF; padding:5px 0;"];globalThis.console.log(...args)}else globalThis.console&&globalThis.console.log(`PixiJS ${VERSION} - ${type} - http://www.pixijs.com/`);saidHello=!0}}class HelloSystem{constructor(renderer){this._renderer=renderer}init(options){if(options.hello){let name=this._renderer.name;this._renderer.type===RendererType.WEBGL&&(name+=` ${this._renderer.context.webGLVersion}`),sayHello(name)}}}HelloSystem.extension={type:[ExtensionType.WebGLSystem,ExtensionType.WebGPUSystem,ExtensionType.CanvasSystem],name:"hello",priority:-2};HelloSystem.defaultOptions={hello:!1};function cleanHash(hash){let clean=!1;for(const i in hash)if(hash[i]==null){clean=!0;break}if(!clean)return hash;const cleanHash2=Object.create(null);for(const i in hash){const value=hash[i];value&&(cleanHash2[i]=value)}return cleanHash2}function cleanArray(arr){let offset=0;for(let i=0;i<arr.length;i++)arr[i]==null?offset++:arr[i-offset]=arr[i];return arr.length-=offset,arr}let renderableGCTick=0;const _RenderableGCSystem=class _RenderableGCSystem2{constructor(renderer){this._managedRenderables=[],this._managedHashes=[],this._managedArrays=[],this._renderer=renderer}init(options){options={..._RenderableGCSystem2.defaultOptions,...options},this.maxUnusedTime=options.renderableGCMaxUnusedTime,this._frequency=options.renderableGCFrequency,this.enabled=options.renderableGCActive}get enabled(){return!!this._handler}set enabled(value){this.enabled!==value&&(value?(this._handler=this._renderer.scheduler.repeat(()=>this.run(),this._frequency,!1),this._hashHandler=this._renderer.scheduler.repeat(()=>{for(const hash of this._managedHashes)hash.context[hash.hash]=cleanHash(hash.context[hash.hash])},this._frequency),this._arrayHandler=this._renderer.scheduler.repeat(()=>{for(const array of this._managedArrays)cleanArray(array.context[array.hash])},this._frequency)):(this._renderer.scheduler.cancel(this._handler),this._renderer.scheduler.cancel(this._hashHandler),this._renderer.scheduler.cancel(this._arrayHandler)))}addManagedHash(context,hash){this._managedHashes.push({context,hash})}addManagedArray(context,hash){this._managedArrays.push({context,hash})}prerender({container}){this._now=performance.now(),container.renderGroup.gcTick=renderableGCTick++,this._updateInstructionGCTick(container.renderGroup,container.renderGroup.gcTick)}addRenderable(renderable){this.enabled&&(renderable._lastUsed===-1&&(this._managedRenderables.push(renderable),renderable.once("destroyed",this._removeRenderable,this)),renderable._lastUsed=this._now)}run(){const now=this._now,managedRenderables=this._managedRenderables,renderPipes=this._renderer.renderPipes;let offset=0;for(let i=0;i<managedRenderables.length;i++){const renderable=managedRenderables[i];if(renderable===null){offset++;continue}const renderGroup=renderable.renderGroup??renderable.parentRenderGroup,currentTick=renderGroup?.instructionSet?.gcTick??-1;if((renderGroup?.gcTick??0)===currentTick&&(renderable._lastUsed=now),now-renderable._lastUsed>this.maxUnusedTime){if(!renderable.destroyed){const rp=renderPipes;renderGroup&&(renderGroup.structureDidChange=!0),rp[renderable.renderPipeId].destroyRenderable(renderable)}renderable._lastUsed=-1,offset++,renderable.off("destroyed",this._removeRenderable,this)}else managedRenderables[i-offset]=renderable}managedRenderables.length-=offset}destroy(){this.enabled=!1,this._renderer=null,this._managedRenderables.length=0,this._managedHashes.length=0,this._managedArrays.length=0}_removeRenderable(renderable){const index=this._managedRenderables.indexOf(renderable);index>=0&&(renderable.off("destroyed",this._removeRenderable,this),this._managedRenderables[index]=null)}_updateInstructionGCTick(renderGroup,gcTick){renderGroup.instructionSet.gcTick=gcTick;for(const child of renderGroup.renderGroupChildren)this._updateInstructionGCTick(child,gcTick)}};_RenderableGCSystem.extension={type:[ExtensionType.WebGLSystem,ExtensionType.WebGPUSystem],name:"renderableGC",priority:0};_RenderableGCSystem.defaultOptions={renderableGCActive:!0,renderableGCMaxUnusedTime:6e4,renderableGCFrequency:3e4};let RenderableGCSystem=_RenderableGCSystem;const _TextureGCSystem=class _TextureGCSystem2{constructor(renderer){this._renderer=renderer,this.count=0,this.checkCount=0}init(options){options={..._TextureGCSystem2.defaultOptions,...options},this.checkCountMax=options.textureGCCheckCountMax,this.maxIdle=options.textureGCAMaxIdle??options.textureGCMaxIdle,this.active=options.textureGCActive}postrender(){this._renderer.renderingToScreen&&(this.count++,this.active&&(this.checkCount++,this.checkCount>this.checkCountMax&&(this.checkCount=0,this.run())))}run(){const managedTextures=this._renderer.texture.managedTextures;for(let i=0;i<managedTextures.length;i++){const texture=managedTextures[i];texture.autoGarbageCollect&&texture.resource&&texture._touched>-1&&this.count-texture._touched>this.maxIdle&&(texture._touched=-1,texture.unload())}}destroy(){this._renderer=null}};_TextureGCSystem.extension={type:[ExtensionType.WebGLSystem,ExtensionType.WebGPUSystem],name:"textureGC"};_TextureGCSystem.defaultOptions={textureGCActive:!0,textureGCAMaxIdle:null,textureGCMaxIdle:60*60,textureGCCheckCountMax:600};let TextureGCSystem=_TextureGCSystem;const _ViewSystem=class _ViewSystem2{get autoDensity(){return this.texture.source.autoDensity}set autoDensity(value){this.texture.source.autoDensity=value}get resolution(){return this.texture.source._resolution}set resolution(value){this.texture.source.resize(this.texture.source.width,this.texture.source.height,value)}init(options){options={..._ViewSystem2.defaultOptions,...options},options.view&&(deprecation(v8_0_0,"ViewSystem.view has been renamed to ViewSystem.canvas"),options.canvas=options.view),this.screen=new Rectangle(0,0,options.width,options.height),this.canvas=options.canvas||DOMAdapter.get().createCanvas(),this.antialias=!!options.antialias,this.texture=getCanvasTexture(this.canvas,options),this.renderTarget=new RenderTarget({colorTextures:[this.texture],depth:!!options.depth,isRoot:!0}),this.texture.source.transparent=options.backgroundAlpha<1,this.resolution=options.resolution}resize(desiredScreenWidth,desiredScreenHeight,resolution){this.texture.source.resize(desiredScreenWidth,desiredScreenHeight,resolution),this.screen.width=this.texture.frame.width,this.screen.height=this.texture.frame.height}destroy(options=!1){(typeof options=="boolean"?options:!!options?.removeView)&&this.canvas.parentNode&&this.canvas.parentNode.removeChild(this.canvas)}};_ViewSystem.extension={type:[ExtensionType.WebGLSystem,ExtensionType.WebGPUSystem,ExtensionType.CanvasSystem],name:"view",priority:0};_ViewSystem.defaultOptions={width:800,height:600,autoDensity:!1,antialias:!1};let ViewSystem=_ViewSystem;const SharedSystems=[BackgroundSystem,GlobalUniformSystem,HelloSystem,ViewSystem,RenderGroupSystem,TextureGCSystem,GenerateTextureSystem,ExtractSystem,RendererInitHook,RenderableGCSystem,SchedulerSystem],SharedRenderPipes=[BlendModePipe,BatcherPipe,SpritePipe,RenderGroupPipe,AlphaMaskPipe,StencilMaskPipe,ColorMaskPipe,CustomRenderPipe];export{BufferResource as B,GpuStencilModesToPixi as G,RenderTargetSystem as R,SharedSystems as S,UboSystem as U,SharedRenderPipes as a,uboSyncFunctionsSTD40 as b,createUboSyncFunction as c,uniformParsers as d,ensureAttributes as e,textureBitGl as f,textureBit as t,uboSyncFunctionsWGSL as u};
