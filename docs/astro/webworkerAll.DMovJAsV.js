import{E as ExtensionType,U as UPDATE_PRIORITY,T as Ticker,a as EventEmitter,$ as deprecation,a0 as v8_0_0,s as Texture,a9 as fontStringFromTextStyle,aa as TextureStyle,ab as CanvasTextMetrics,N as Rectangle,l as CanvasPool,ac as ImageSource,ad as getCanvasFillStyle,Y as Color,ae as TextStyle,af as Cache,w as warn,k as UniformGroup,c as BindGroup,F as TexturePool,M as Matrix,a2 as Geometry,R as RendererType,z as Bounds,b as Buffer,B as BufferUsage,x as BigPool,ag as BatchableGraphics,ah as getAdjustedBlendModeBlend,J as getAttributeInfoFromFormat,ai as ViewableBuffer,q as Shader,t as GlProgram,G as GpuProgram,m as compileHighShaderGpuProgram,p as roundPixelsBit,a4 as compileHighShaderGlProgram,a7 as roundPixelsBitGl,n as colorBit,o as generateTextureBatchBit,a5 as colorBitGl,a6 as generateTextureBatchBitGl,a8 as getBatchSamplersUniformGroup,aj as Graphics,ak as updateQuadBounds,D as DOMAdapter,al as CanvasTextGenerator,e as extensions,am as GraphicsContextSystem}from"./DemoScript.astro_astro_type_script_index_0_lang.CG-6-1R_.js";import{S as State,c as color32BitToUniform,a as localUniformBit,b as localUniformBitGl,B as BatchableSprite}from"./colorToUniform.Db5An2aa.js";import"./preload-helper.oD9tGONt.js";class ResizePlugin{static init(options){Object.defineProperty(this,"resizeTo",{set(dom){globalThis.removeEventListener("resize",this.queueResize),this._resizeTo=dom,dom&&(globalThis.addEventListener("resize",this.queueResize),this.resize())},get(){return this._resizeTo}}),this.queueResize=()=>{this._resizeTo&&(this._cancelResize(),this._resizeId=requestAnimationFrame(()=>this.resize()))},this._cancelResize=()=>{this._resizeId&&(cancelAnimationFrame(this._resizeId),this._resizeId=null)},this.resize=()=>{if(!this._resizeTo)return;this._cancelResize();let width,height;if(this._resizeTo===globalThis.window)width=globalThis.innerWidth,height=globalThis.innerHeight;else{const{clientWidth,clientHeight}=this._resizeTo;width=clientWidth,height=clientHeight}this.renderer.resize(width,height),this.render()},this._resizeId=null,this._resizeTo=null,this.resizeTo=options.resizeTo||null}static destroy(){globalThis.removeEventListener("resize",this.queueResize),this._cancelResize(),this._cancelResize=null,this.queueResize=null,this.resizeTo=null,this.resize=null}}ResizePlugin.extension=ExtensionType.Application;class TickerPlugin{static init(options){options=Object.assign({autoStart:!0,sharedTicker:!1},options),Object.defineProperty(this,"ticker",{set(ticker){this._ticker&&this._ticker.remove(this.render,this),this._ticker=ticker,ticker&&ticker.add(this.render,this,UPDATE_PRIORITY.LOW)},get(){return this._ticker}}),this.stop=()=>{this._ticker.stop()},this.start=()=>{this._ticker.start()},this._ticker=null,this.ticker=options.sharedTicker?Ticker.shared:new Ticker,options.autoStart&&this.start()}static destroy(){if(this._ticker){const oldTicker=this._ticker;this.ticker=null,oldTicker.destroy()}}}TickerPlugin.extension=ExtensionType.Application;class AbstractBitmapFont extends EventEmitter{constructor(){super(...arguments),this.chars=Object.create(null),this.lineHeight=0,this.fontFamily="",this.fontMetrics={fontSize:0,ascent:0,descent:0},this.baseLineOffset=0,this.distanceField={type:"none",range:0},this.pages=[],this.applyFillAsTint=!0,this.baseMeasurementFontSize=100,this.baseRenderedFontSize=100}get font(){return deprecation(v8_0_0,"BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead."),this.fontFamily}get pageTextures(){return deprecation(v8_0_0,"BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."),this.pages}get size(){return deprecation(v8_0_0,"BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead."),this.fontMetrics.fontSize}get distanceFieldRange(){return deprecation(v8_0_0,"BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead."),this.distanceField.range}get distanceFieldType(){return deprecation(v8_0_0,"BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead."),this.distanceField.type}destroy(destroyTextures=!1){this.emit("destroy",this),this.removeAllListeners();for(const i in this.chars)this.chars[i].texture?.destroy();this.chars=null,destroyTextures&&(this.pages.forEach(page=>page.texture.destroy(!0)),this.pages=null)}}const _DynamicBitmapFont=class _DynamicBitmapFont2 extends AbstractBitmapFont{constructor(options){super(),this.resolution=1,this.pages=[],this._padding=0,this._measureCache=Object.create(null),this._currentChars=[],this._currentX=0,this._currentY=0,this._currentMaxCharHeight=0,this._currentPageIndex=-1,this._skipKerning=!1;const dynamicOptions={..._DynamicBitmapFont2.defaultOptions,...options};this._textureSize=dynamicOptions.textureSize,this._mipmap=dynamicOptions.mipmap;const style=dynamicOptions.style.clone();dynamicOptions.overrideFill&&(style._fill.color=16777215,style._fill.alpha=1,style._fill.texture=Texture.WHITE,style._fill.fill=null),this.applyFillAsTint=dynamicOptions.overrideFill;const requestedFontSize=style.fontSize;style.fontSize=this.baseMeasurementFontSize;const font=fontStringFromTextStyle(style);dynamicOptions.overrideSize?style._stroke&&(style._stroke.width*=this.baseRenderedFontSize/requestedFontSize):style.fontSize=this.baseRenderedFontSize=requestedFontSize,this._style=style,this._skipKerning=dynamicOptions.skipKerning??!1,this.resolution=dynamicOptions.resolution??1,this._padding=dynamicOptions.padding??4,dynamicOptions.textureStyle&&(this._textureStyle=dynamicOptions.textureStyle instanceof TextureStyle?dynamicOptions.textureStyle:new TextureStyle(dynamicOptions.textureStyle)),this.fontMetrics=CanvasTextMetrics.measureFont(font),this.lineHeight=style.lineHeight||this.fontMetrics.fontSize||style.fontSize}ensureCharacters(chars){const charList=CanvasTextMetrics.graphemeSegmenter(chars).filter(char=>!this._currentChars.includes(char)).filter((char,index,self)=>self.indexOf(char)===index);if(!charList.length)return;this._currentChars=[...this._currentChars,...charList];let pageData;this._currentPageIndex===-1?pageData=this._nextPage():pageData=this.pages[this._currentPageIndex];let{canvas,context}=pageData.canvasAndContext,textureSource=pageData.texture.source;const style=this._style;let currentX=this._currentX,currentY=this._currentY,currentMaxCharHeight=this._currentMaxCharHeight;const fontScale=this.baseRenderedFontSize/this.baseMeasurementFontSize,padding=this._padding*fontScale;let skipTexture=!1;const maxTextureWidth=canvas.width/this.resolution,maxTextureHeight=canvas.height/this.resolution;for(let i=0;i<charList.length;i++){const char=charList[i],metrics=CanvasTextMetrics.measureText(char,style,canvas,!1);metrics.lineHeight=metrics.height;const width=metrics.width*fontScale,textureGlyphWidth=Math.ceil((style.fontStyle==="italic"?2:1)*width),height=metrics.height*fontScale,paddedWidth=textureGlyphWidth+padding*2,paddedHeight=height+padding*2;if(skipTexture=!1,char!==`
`&&char!=="\r"&&char!=="	"&&char!==" "&&(skipTexture=!0,currentMaxCharHeight=Math.ceil(Math.max(paddedHeight,currentMaxCharHeight))),currentX+paddedWidth>maxTextureWidth&&(currentY+=currentMaxCharHeight,currentMaxCharHeight=paddedHeight,currentX=0,currentY+currentMaxCharHeight>maxTextureHeight)){textureSource.update();const pageData2=this._nextPage();canvas=pageData2.canvasAndContext.canvas,context=pageData2.canvasAndContext.context,textureSource=pageData2.texture.source,currentX=0,currentY=0,currentMaxCharHeight=0}const xAdvance=width/fontScale-(style.dropShadow?.distance??0)-(style._stroke?.width??0);if(this.chars[char]={id:char.codePointAt(0),xOffset:-this._padding,yOffset:-this._padding,xAdvance,kerning:{}},skipTexture){this._drawGlyph(context,metrics,currentX+padding,currentY+padding,fontScale,style);const px=textureSource.width*fontScale,py=textureSource.height*fontScale,frame=new Rectangle(currentX/px*textureSource.width,currentY/py*textureSource.height,paddedWidth/px*textureSource.width,paddedHeight/py*textureSource.height);this.chars[char].texture=new Texture({source:textureSource,frame}),currentX+=Math.ceil(paddedWidth)}}textureSource.update(),this._currentX=currentX,this._currentY=currentY,this._currentMaxCharHeight=currentMaxCharHeight,this._skipKerning&&this._applyKerning(charList,context)}get pageTextures(){return deprecation(v8_0_0,"BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."),this.pages}_applyKerning(newChars,context){const measureCache=this._measureCache;for(let i=0;i<newChars.length;i++){const first=newChars[i];for(let j=0;j<this._currentChars.length;j++){const second=this._currentChars[j];let c1=measureCache[first];c1||(c1=measureCache[first]=context.measureText(first).width);let c2=measureCache[second];c2||(c2=measureCache[second]=context.measureText(second).width);let total=context.measureText(first+second).width,amount=total-(c1+c2);amount&&(this.chars[first].kerning[second]=amount),total=context.measureText(first+second).width,amount=total-(c1+c2),amount&&(this.chars[second].kerning[first]=amount)}}}_nextPage(){this._currentPageIndex++;const textureResolution=this.resolution,canvasAndContext=CanvasPool.getOptimalCanvasAndContext(this._textureSize,this._textureSize,textureResolution);this._setupContext(canvasAndContext.context,this._style,textureResolution);const resolution=textureResolution*(this.baseRenderedFontSize/this.baseMeasurementFontSize),texture=new Texture({source:new ImageSource({resource:canvasAndContext.canvas,resolution,alphaMode:"premultiply-alpha-on-upload",autoGenerateMipmaps:this._mipmap})});this._textureStyle&&(texture.source.style=this._textureStyle);const pageData={canvasAndContext,texture};return this.pages[this._currentPageIndex]=pageData,pageData}_setupContext(context,style,resolution){style.fontSize=this.baseRenderedFontSize,context.scale(resolution,resolution),context.font=fontStringFromTextStyle(style),style.fontSize=this.baseMeasurementFontSize,context.textBaseline=style.textBaseline;const stroke=style._stroke,strokeThickness=stroke?.width??0;if(stroke&&(context.lineWidth=strokeThickness,context.lineJoin=stroke.join,context.miterLimit=stroke.miterLimit,context.strokeStyle=getCanvasFillStyle(stroke,context)),style._fill&&(context.fillStyle=getCanvasFillStyle(style._fill,context)),style.dropShadow){const shadowOptions=style.dropShadow,rgb=Color.shared.setValue(shadowOptions.color).toArray(),dropShadowBlur=shadowOptions.blur*resolution,dropShadowDistance=shadowOptions.distance*resolution;context.shadowColor=`rgba(${rgb[0]*255},${rgb[1]*255},${rgb[2]*255},${shadowOptions.alpha})`,context.shadowBlur=dropShadowBlur,context.shadowOffsetX=Math.cos(shadowOptions.angle)*dropShadowDistance,context.shadowOffsetY=Math.sin(shadowOptions.angle)*dropShadowDistance}else context.shadowColor="black",context.shadowBlur=0,context.shadowOffsetX=0,context.shadowOffsetY=0}_drawGlyph(context,metrics,x,y,fontScale,style){const char=metrics.text,fontProperties=metrics.fontProperties,strokeThickness=(style._stroke?.width??0)*fontScale,tx=x+strokeThickness/2,ty=y-strokeThickness/2,descent=fontProperties.descent*fontScale,lineHeight=metrics.lineHeight*fontScale;style.stroke&&strokeThickness&&context.strokeText(char,tx,ty+lineHeight-descent),style._fill&&context.fillText(char,tx,ty+lineHeight-descent)}destroy(){super.destroy();for(let i=0;i<this.pages.length;i++){const{canvasAndContext,texture}=this.pages[i];CanvasPool.returnCanvasAndContext(canvasAndContext),texture.destroy(!0)}this.pages=null}};_DynamicBitmapFont.defaultOptions={textureSize:512,style:new TextStyle,mipmap:!0};let DynamicBitmapFont=_DynamicBitmapFont;function getBitmapTextLayout(chars,style,font,trimEnd){const layoutData={width:0,height:0,offsetY:0,scale:style.fontSize/font.baseMeasurementFontSize,lines:[{width:0,charPositions:[],spaceWidth:0,spacesIndex:[],chars:[]}]};layoutData.offsetY=font.baseLineOffset;let currentLine=layoutData.lines[0],previousChar=null,firstWord=!0;const currentWord={width:0,start:0,index:0,positions:[],chars:[]},nextWord=word=>{const start=currentLine.width;for(let j=0;j<currentWord.index;j++){const position=word.positions[j];currentLine.chars.push(word.chars[j]),currentLine.charPositions.push(position+start)}currentLine.width+=word.width,firstWord=!1,currentWord.width=0,currentWord.index=0,currentWord.chars.length=0},nextLine=()=>{let index=currentLine.chars.length-1;if(trimEnd){let lastChar=currentLine.chars[index];for(;lastChar===" ";)currentLine.width-=font.chars[lastChar].xAdvance,lastChar=currentLine.chars[--index]}layoutData.width=Math.max(layoutData.width,currentLine.width),currentLine={width:0,charPositions:[],chars:[],spaceWidth:0,spacesIndex:[]},firstWord=!0,layoutData.lines.push(currentLine),layoutData.height+=font.lineHeight},scale=font.baseMeasurementFontSize/style.fontSize,adjustedLetterSpacing=style.letterSpacing*scale,adjustedWordWrapWidth=style.wordWrapWidth*scale;for(let i=0;i<chars.length+1;i++){let char;const isEnd=i===chars.length;isEnd||(char=chars[i]);const charData=font.chars[char]||font.chars[" "];if(/(?:\s)/.test(char)||char==="\r"||char===`
`||isEnd){if(!firstWord&&style.wordWrap&&currentLine.width+currentWord.width-adjustedLetterSpacing>adjustedWordWrapWidth?(nextLine(),nextWord(currentWord),isEnd||currentLine.charPositions.push(0)):(currentWord.start=currentLine.width,nextWord(currentWord),isEnd||currentLine.charPositions.push(0)),char==="\r"||char===`
`)currentLine.width!==0&&nextLine();else if(!isEnd){const spaceWidth=charData.xAdvance+(charData.kerning[previousChar]||0)+adjustedLetterSpacing;currentLine.width+=spaceWidth,currentLine.spaceWidth=spaceWidth,currentLine.spacesIndex.push(currentLine.charPositions.length),currentLine.chars.push(char)}}else{const kerning=charData.kerning[previousChar]||0,nextCharWidth=charData.xAdvance+kerning+adjustedLetterSpacing;currentWord.positions[currentWord.index++]=currentWord.width+kerning,currentWord.chars.push(char),currentWord.width+=nextCharWidth}previousChar=char}return nextLine(),style.align==="center"?alignCenter(layoutData):style.align==="right"?alignRight(layoutData):style.align==="justify"&&alignJustify(layoutData),layoutData}function alignCenter(measurementData){for(let i=0;i<measurementData.lines.length;i++){const line=measurementData.lines[i],offset=measurementData.width/2-line.width/2;for(let j=0;j<line.charPositions.length;j++)line.charPositions[j]+=offset}}function alignRight(measurementData){for(let i=0;i<measurementData.lines.length;i++){const line=measurementData.lines[i],offset=measurementData.width-line.width;for(let j=0;j<line.charPositions.length;j++)line.charPositions[j]+=offset}}function alignJustify(measurementData){const width=measurementData.width;for(let i=0;i<measurementData.lines.length;i++){const line=measurementData.lines[i];let indy=0,spaceIndex=line.spacesIndex[indy++],offset=0;const totalSpaces=line.spacesIndex.length,spaceWidth=(width-line.width)/totalSpaces;for(let j=0;j<line.charPositions.length;j++)j===spaceIndex&&(spaceIndex=line.spacesIndex[indy++],offset+=spaceWidth),line.charPositions[j]+=offset}}function resolveCharacters(chars){if(chars==="")return[];typeof chars=="string"&&(chars=[chars]);const result=[];for(let i=0,j=chars.length;i<j;i++){const item=chars[i];if(Array.isArray(item)){if(item.length!==2)throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);if(item[0].length===0||item[1].length===0)throw new Error("[BitmapFont]: Invalid character delimiter.");const startCode=item[0].charCodeAt(0),endCode=item[1].charCodeAt(0);if(endCode<startCode)throw new Error("[BitmapFont]: Invalid character range.");for(let i2=startCode,j2=endCode;i2<=j2;i2++)result.push(String.fromCharCode(i2))}else result.push(...Array.from(item))}if(result.length===0)throw new Error("[BitmapFont]: Empty set when resolving characters.");return result}let fontCount=0;class BitmapFontManagerClass{constructor(){this.ALPHA=[["a","z"],["A","Z"]," "],this.NUMERIC=[["0","9"]],this.ALPHANUMERIC=[["a","z"],["A","Z"],["0","9"]," "],this.ASCII=[[" ","~"]],this.defaultOptions={chars:this.ALPHANUMERIC,resolution:1,padding:4,skipKerning:!1,textureStyle:null}}getFont(text,style){let fontFamilyKey=`${style.fontFamily}-bitmap`,overrideFill=!0;if(style._fill.fill&&!style._stroke)fontFamilyKey+=style._fill.fill.styleKey,overrideFill=!1;else if(style._stroke||style.dropShadow){let key=style.styleKey;key=key.substring(0,key.lastIndexOf("-")),fontFamilyKey=`${key}-bitmap`,overrideFill=!1}if(!Cache.has(fontFamilyKey)){const fnt=new DynamicBitmapFont({style,overrideFill,overrideSize:!0,...this.defaultOptions});fontCount++,fontCount>50&&warn("BitmapText",`You have dynamically created ${fontCount} bitmap fonts, this can be inefficient. Try pre installing your font styles using \`BitmapFont.install({name:"style1", style})\``),fnt.once("destroy",()=>{fontCount--,Cache.remove(fontFamilyKey)}),Cache.set(fontFamilyKey,fnt)}const dynamicFont=Cache.get(fontFamilyKey);return dynamicFont.ensureCharacters?.(text),dynamicFont}getLayout(text,style,trimEnd=!0){const bitmapFont=this.getFont(text,style),segments=CanvasTextMetrics.graphemeSegmenter(text);return getBitmapTextLayout(segments,style,bitmapFont,trimEnd)}measureText(text,style,trimEnd=!0){return this.getLayout(text,style,trimEnd)}install(...args){let options=args[0];typeof options=="string"&&(options={name:options,style:args[1],chars:args[2]?.chars,resolution:args[2]?.resolution,padding:args[2]?.padding,skipKerning:args[2]?.skipKerning},deprecation(v8_0_0,"BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})"));const name=options?.name;if(!name)throw new Error("[BitmapFontManager] Property `name` is required.");options={...this.defaultOptions,...options};const textStyle=options.style,style=textStyle instanceof TextStyle?textStyle:new TextStyle(textStyle),overrideFill=style._fill.fill!==null&&style._fill.fill!==void 0,font=new DynamicBitmapFont({style,overrideFill,skipKerning:options.skipKerning,padding:options.padding,resolution:options.resolution,overrideSize:!1,textureStyle:options.textureStyle}),flatChars=resolveCharacters(options.chars);return font.ensureCharacters(flatChars.join("")),Cache.set(`${name}-bitmap`,font),font.once("destroy",()=>Cache.remove(`${name}-bitmap`)),font}uninstall(name){const cacheKey=`${name}-bitmap`,font=Cache.get(cacheKey);font&&font.destroy()}}const BitmapFontManager=new BitmapFontManagerClass;class FilterPipe{constructor(renderer){this._renderer=renderer}push(filterEffect,container,instructionSet){this._renderer.renderPipes.batch.break(instructionSet),instructionSet.add({renderPipeId:"filter",canBundle:!1,action:"pushFilter",container,filterEffect})}pop(_filterEffect,_container,instructionSet){this._renderer.renderPipes.batch.break(instructionSet),instructionSet.add({renderPipeId:"filter",action:"popFilter",canBundle:!1})}execute(instruction){instruction.action==="pushFilter"?this._renderer.filter.push(instruction):instruction.action==="popFilter"&&this._renderer.filter.pop()}destroy(){this._renderer=null}}FilterPipe.extension={type:[ExtensionType.WebGLPipes,ExtensionType.WebGPUPipes,ExtensionType.CanvasPipes],name:"filter"};function getGlobalRenderableBounds(renderables,bounds){bounds.clear();const tempMatrix=bounds.matrix;for(let i=0;i<renderables.length;i++){const renderable=renderables[i];renderable.globalDisplayStatus<7||(bounds.matrix=renderable.worldTransform,bounds.addBounds(renderable.bounds))}return bounds.matrix=tempMatrix,bounds}const quadGeometry=new Geometry({attributes:{aPosition:{buffer:new Float32Array([0,0,1,0,1,1,0,1]),format:"float32x2",stride:2*4,offset:0}},indexBuffer:new Uint32Array([0,1,2,0,2,3])});class FilterData{constructor(){this.skip=!1,this.inputTexture=null,this.backTexture=null,this.filters=null,this.bounds=new Bounds,this.container=null,this.blendRequired=!1,this.outputRenderSurface=null,this.globalFrame={x:0,y:0,width:0,height:0}}}class FilterSystem{constructor(renderer){this._filterStackIndex=0,this._filterStack=[],this._filterGlobalUniforms=new UniformGroup({uInputSize:{value:new Float32Array(4),type:"vec4<f32>"},uInputPixel:{value:new Float32Array(4),type:"vec4<f32>"},uInputClamp:{value:new Float32Array(4),type:"vec4<f32>"},uOutputFrame:{value:new Float32Array(4),type:"vec4<f32>"},uGlobalFrame:{value:new Float32Array(4),type:"vec4<f32>"},uOutputTexture:{value:new Float32Array(4),type:"vec4<f32>"}}),this._globalFilterBindGroup=new BindGroup({}),this.renderer=renderer}get activeBackTexture(){return this._activeFilterData?.backTexture}push(instruction){const renderer=this.renderer,filters=instruction.filterEffect.filters,filterData=this._pushFilterData();filterData.skip=!1,filterData.filters=filters,filterData.container=instruction.container,filterData.outputRenderSurface=renderer.renderTarget.renderSurface;const colorTextureSource=renderer.renderTarget.renderTarget.colorTexture.source,rootResolution=colorTextureSource.resolution,rootAntialias=colorTextureSource.antialias;if(filters.length===0){filterData.skip=!0;return}const bounds=filterData.bounds;if(this._calculateFilterArea(instruction,bounds),this._calculateFilterBounds(filterData,renderer.renderTarget.rootViewPort,rootAntialias,rootResolution,1),filterData.skip)return;const previousFilterData=this._getPreviousFilterData(),globalResolution=this._findFilterResolution(rootResolution);let offsetX=0,offsetY=0;previousFilterData&&(offsetX=previousFilterData.bounds.minX,offsetY=previousFilterData.bounds.minY),this._calculateGlobalFrame(filterData,offsetX,offsetY,globalResolution,colorTextureSource.width,colorTextureSource.height),this._setupFilterTextures(filterData,bounds,renderer,previousFilterData)}generateFilteredTexture({texture,filters}){const filterData=this._pushFilterData();this._activeFilterData=filterData,filterData.skip=!1,filterData.filters=filters;const colorTextureSource=texture.source,rootResolution=colorTextureSource.resolution,rootAntialias=colorTextureSource.antialias;if(filters.length===0)return filterData.skip=!0,texture;const bounds=filterData.bounds;if(bounds.addRect(texture.frame),this._calculateFilterBounds(filterData,bounds.rectangle,rootAntialias,rootResolution,0),filterData.skip)return texture;const globalResolution=rootResolution;this._calculateGlobalFrame(filterData,0,0,globalResolution,colorTextureSource.width,colorTextureSource.height),filterData.outputRenderSurface=TexturePool.getOptimalTexture(bounds.width,bounds.height,filterData.resolution,filterData.antialias),filterData.backTexture=Texture.EMPTY,filterData.inputTexture=texture,this.renderer.renderTarget.finishRenderPass(),this._applyFiltersToTexture(filterData,!0);const outputTexture=filterData.outputRenderSurface;return outputTexture.source.alphaMode="premultiplied-alpha",outputTexture}pop(){const renderer=this.renderer,filterData=this._popFilterData();filterData.skip||(renderer.globalUniforms.pop(),renderer.renderTarget.finishRenderPass(),this._activeFilterData=filterData,this._applyFiltersToTexture(filterData,!1),filterData.blendRequired&&TexturePool.returnTexture(filterData.backTexture),TexturePool.returnTexture(filterData.inputTexture))}getBackTexture(lastRenderSurface,bounds,previousBounds){const backgroundResolution=lastRenderSurface.colorTexture.source._resolution,backTexture=TexturePool.getOptimalTexture(bounds.width,bounds.height,backgroundResolution,!1);let x=bounds.minX,y=bounds.minY;previousBounds&&(x-=previousBounds.minX,y-=previousBounds.minY),x=Math.floor(x*backgroundResolution),y=Math.floor(y*backgroundResolution);const width=Math.ceil(bounds.width*backgroundResolution),height=Math.ceil(bounds.height*backgroundResolution);return this.renderer.renderTarget.copyToTexture(lastRenderSurface,backTexture,{x,y},{width,height},{x:0,y:0}),backTexture}applyFilter(filter,input,output,clear){const renderer=this.renderer,filterData=this._activeFilterData,isFinalTarget=filterData.outputRenderSurface===output,rootResolution=renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution,resolution=this._findFilterResolution(rootResolution);let offsetX=0,offsetY=0;if(isFinalTarget){const offset=this._findPreviousFilterOffset();offsetX=offset.x,offsetY=offset.y}this._updateFilterUniforms(input,output,filterData,offsetX,offsetY,resolution,isFinalTarget,clear),this._setupBindGroupsAndRender(filter,input,renderer)}calculateSpriteMatrix(outputMatrix,sprite){const data=this._activeFilterData,mappedMatrix=outputMatrix.set(data.inputTexture._source.width,0,0,data.inputTexture._source.height,data.bounds.minX,data.bounds.minY),worldTransform=sprite.worldTransform.copyTo(Matrix.shared),renderGroup=sprite.renderGroup||sprite.parentRenderGroup;return renderGroup&&renderGroup.cacheToLocalTransform&&worldTransform.prepend(renderGroup.cacheToLocalTransform),worldTransform.invert(),mappedMatrix.prepend(worldTransform),mappedMatrix.scale(1/sprite.texture.frame.width,1/sprite.texture.frame.height),mappedMatrix.translate(sprite.anchor.x,sprite.anchor.y),mappedMatrix}destroy(){}_setupBindGroupsAndRender(filter,input,renderer){if(renderer.renderPipes.uniformBatch){const batchUniforms=renderer.renderPipes.uniformBatch.getUboResource(this._filterGlobalUniforms);this._globalFilterBindGroup.setResource(batchUniforms,0)}else this._globalFilterBindGroup.setResource(this._filterGlobalUniforms,0);this._globalFilterBindGroup.setResource(input.source,1),this._globalFilterBindGroup.setResource(input.source.style,2),filter.groups[0]=this._globalFilterBindGroup,renderer.encoder.draw({geometry:quadGeometry,shader:filter,state:filter._state,topology:"triangle-list"}),renderer.type===RendererType.WEBGL&&renderer.renderTarget.finishRenderPass()}_setupFilterTextures(filterData,bounds,renderer,previousFilterData){if(filterData.backTexture=Texture.EMPTY,filterData.blendRequired){renderer.renderTarget.finishRenderPass();const renderTarget=renderer.renderTarget.getRenderTarget(filterData.outputRenderSurface);filterData.backTexture=this.getBackTexture(renderTarget,bounds,previousFilterData?.bounds)}filterData.inputTexture=TexturePool.getOptimalTexture(bounds.width,bounds.height,filterData.resolution,filterData.antialias),renderer.renderTarget.bind(filterData.inputTexture,!0),renderer.globalUniforms.push({offset:bounds})}_calculateGlobalFrame(filterData,offsetX,offsetY,globalResolution,sourceWidth,sourceHeight){const globalFrame=filterData.globalFrame;globalFrame.x=offsetX*globalResolution,globalFrame.y=offsetY*globalResolution,globalFrame.width=sourceWidth*globalResolution,globalFrame.height=sourceHeight*globalResolution}_updateFilterUniforms(input,output,filterData,offsetX,offsetY,resolution,isFinalTarget,clear){const uniforms=this._filterGlobalUniforms.uniforms,outputFrame=uniforms.uOutputFrame,inputSize=uniforms.uInputSize,inputPixel=uniforms.uInputPixel,inputClamp=uniforms.uInputClamp,globalFrame=uniforms.uGlobalFrame,outputTexture=uniforms.uOutputTexture;isFinalTarget?(outputFrame[0]=filterData.bounds.minX-offsetX,outputFrame[1]=filterData.bounds.minY-offsetY):(outputFrame[0]=0,outputFrame[1]=0),outputFrame[2]=input.frame.width,outputFrame[3]=input.frame.height,inputSize[0]=input.source.width,inputSize[1]=input.source.height,inputSize[2]=1/inputSize[0],inputSize[3]=1/inputSize[1],inputPixel[0]=input.source.pixelWidth,inputPixel[1]=input.source.pixelHeight,inputPixel[2]=1/inputPixel[0],inputPixel[3]=1/inputPixel[1],inputClamp[0]=.5*inputPixel[2],inputClamp[1]=.5*inputPixel[3],inputClamp[2]=input.frame.width*inputSize[2]-.5*inputPixel[2],inputClamp[3]=input.frame.height*inputSize[3]-.5*inputPixel[3];const rootTexture=this.renderer.renderTarget.rootRenderTarget.colorTexture;globalFrame[0]=offsetX*resolution,globalFrame[1]=offsetY*resolution,globalFrame[2]=rootTexture.source.width*resolution,globalFrame[3]=rootTexture.source.height*resolution,output instanceof Texture&&(output.source.resource=null);const renderTarget=this.renderer.renderTarget.getRenderTarget(output);this.renderer.renderTarget.bind(output,!!clear),output instanceof Texture?(outputTexture[0]=output.frame.width,outputTexture[1]=output.frame.height):(outputTexture[0]=renderTarget.width,outputTexture[1]=renderTarget.height),outputTexture[2]=renderTarget.isRoot?-1:1,this._filterGlobalUniforms.update()}_findFilterResolution(rootResolution){let currentIndex=this._filterStackIndex-1;for(;currentIndex>0&&this._filterStack[currentIndex].skip;)--currentIndex;return currentIndex>0&&this._filterStack[currentIndex].inputTexture?this._filterStack[currentIndex].inputTexture.source._resolution:rootResolution}_findPreviousFilterOffset(){let offsetX=0,offsetY=0,lastIndex=this._filterStackIndex;for(;lastIndex>0;){lastIndex--;const prevFilterData=this._filterStack[lastIndex];if(!prevFilterData.skip){offsetX=prevFilterData.bounds.minX,offsetY=prevFilterData.bounds.minY;break}}return{x:offsetX,y:offsetY}}_calculateFilterArea(instruction,bounds){if(instruction.renderables?getGlobalRenderableBounds(instruction.renderables,bounds):instruction.filterEffect.filterArea?(bounds.clear(),bounds.addRect(instruction.filterEffect.filterArea),bounds.applyMatrix(instruction.container.worldTransform)):instruction.container.getFastGlobalBounds(!0,bounds),instruction.container){const filterFrameTransform=(instruction.container.renderGroup||instruction.container.parentRenderGroup).cacheToLocalTransform;filterFrameTransform&&bounds.applyMatrix(filterFrameTransform)}}_applyFiltersToTexture(filterData,clear){const inputTexture=filterData.inputTexture,bounds=filterData.bounds,filters=filterData.filters;if(this._globalFilterBindGroup.setResource(inputTexture.source.style,2),this._globalFilterBindGroup.setResource(filterData.backTexture.source,3),filters.length===1)filters[0].apply(this,inputTexture,filterData.outputRenderSurface,clear);else{let flip=filterData.inputTexture;const tempTexture=TexturePool.getOptimalTexture(bounds.width,bounds.height,flip.source._resolution,!1);let flop=tempTexture,i=0;for(i=0;i<filters.length-1;++i){filters[i].apply(this,flip,flop,!0);const t=flip;flip=flop,flop=t}filters[i].apply(this,flip,filterData.outputRenderSurface,clear),TexturePool.returnTexture(tempTexture)}}_calculateFilterBounds(filterData,viewPort,rootAntialias,rootResolution,paddingMultiplier){const renderer=this.renderer,bounds=filterData.bounds,filters=filterData.filters;let resolution=1/0,padding=0,antialias=!0,blendRequired=!1,enabled=!1,clipToViewport=!0;for(let i=0;i<filters.length;i++){const filter=filters[i];if(resolution=Math.min(resolution,filter.resolution==="inherit"?rootResolution:filter.resolution),padding+=filter.padding,filter.antialias==="off"?antialias=!1:filter.antialias==="inherit"&&antialias&&(antialias=rootAntialias),filter.clipToViewport||(clipToViewport=!1),!!!(filter.compatibleRenderers&renderer.type)){enabled=!1;break}if(filter.blendRequired&&!(renderer.backBuffer?.useBackBuffer??!0)){warn("Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options."),enabled=!1;break}enabled=filter.enabled||enabled,blendRequired||(blendRequired=filter.blendRequired)}if(!enabled){filterData.skip=!0;return}if(clipToViewport&&bounds.fitBounds(0,viewPort.width/rootResolution,0,viewPort.height/rootResolution),bounds.scale(resolution).ceil().scale(1/resolution).pad((padding|0)*paddingMultiplier),!bounds.isPositive){filterData.skip=!0;return}filterData.antialias=antialias,filterData.resolution=resolution,filterData.blendRequired=blendRequired}_popFilterData(){return this._filterStackIndex--,this._filterStack[this._filterStackIndex]}_getPreviousFilterData(){let previousFilterData,index=this._filterStackIndex-1;for(;index>1&&(index--,previousFilterData=this._filterStack[index],!!previousFilterData.skip););return previousFilterData}_pushFilterData(){let filterData=this._filterStack[this._filterStackIndex];return filterData||(filterData=this._filterStack[this._filterStackIndex]=new FilterData),this._filterStackIndex++,filterData}}FilterSystem.extension={type:[ExtensionType.WebGLSystem,ExtensionType.WebGPUSystem],name:"filter"};const _MeshGeometry=class _MeshGeometry2 extends Geometry{constructor(...args){let options=args[0]??{};options instanceof Float32Array&&(deprecation(v8_0_0,"use new MeshGeometry({ positions, uvs, indices }) instead"),options={positions:options,uvs:args[1],indices:args[2]}),options={..._MeshGeometry2.defaultOptions,...options};const positions=options.positions||new Float32Array([0,0,1,0,1,1,0,1]);let uvs=options.uvs;uvs||(options.positions?uvs=new Float32Array(positions.length):uvs=new Float32Array([0,0,1,0,1,1,0,1]));const indices=options.indices||new Uint32Array([0,1,2,0,2,3]),shrinkToFit=options.shrinkBuffersToFit,positionBuffer=new Buffer({data:positions,label:"attribute-mesh-positions",shrinkToFit,usage:BufferUsage.VERTEX|BufferUsage.COPY_DST}),uvBuffer=new Buffer({data:uvs,label:"attribute-mesh-uvs",shrinkToFit,usage:BufferUsage.VERTEX|BufferUsage.COPY_DST}),indexBuffer=new Buffer({data:indices,label:"index-mesh-buffer",shrinkToFit,usage:BufferUsage.INDEX|BufferUsage.COPY_DST});super({attributes:{aPosition:{buffer:positionBuffer,format:"float32x2",stride:2*4,offset:0},aUV:{buffer:uvBuffer,format:"float32x2",stride:2*4,offset:0}},indexBuffer,topology:options.topology}),this.batchMode="auto"}get positions(){return this.attributes.aPosition.buffer.data}set positions(value){this.attributes.aPosition.buffer.data=value}get uvs(){return this.attributes.aUV.buffer.data}set uvs(value){this.attributes.aUV.buffer.data=value}get indices(){return this.indexBuffer.data}set indices(value){this.indexBuffer.data=value}};_MeshGeometry.defaultOptions={topology:"triangle-list",shrinkBuffersToFit:!1};let MeshGeometry=_MeshGeometry;function textStyleToCSS(style){const stroke=style._stroke,fill=style._fill,cssStyles=[`div { ${[`color: ${Color.shared.setValue(fill.color).toHex()}`,`font-size: ${style.fontSize}px`,`font-family: ${style.fontFamily}`,`font-weight: ${style.fontWeight}`,`font-style: ${style.fontStyle}`,`font-variant: ${style.fontVariant}`,`letter-spacing: ${style.letterSpacing}px`,`text-align: ${style.align}`,`padding: ${style.padding}px`,`white-space: ${style.whiteSpace==="pre"&&style.wordWrap?"pre-wrap":style.whiteSpace}`,...style.lineHeight?[`line-height: ${style.lineHeight}px`]:[],...style.wordWrap?[`word-wrap: ${style.breakWords?"break-all":"break-word"}`,`max-width: ${style.wordWrapWidth}px`]:[],...stroke?[strokeToCSS(stroke)]:[],...style.dropShadow?[dropShadowToCSS(style.dropShadow)]:[],...style.cssOverrides].join(";")} }`];return tagStyleToCSS(style.tagStyles,cssStyles),cssStyles.join(" ")}function dropShadowToCSS(dropShadowStyle){const color=Color.shared.setValue(dropShadowStyle.color).setAlpha(dropShadowStyle.alpha).toHexa(),x=Math.round(Math.cos(dropShadowStyle.angle)*dropShadowStyle.distance),y=Math.round(Math.sin(dropShadowStyle.angle)*dropShadowStyle.distance),position=`${x}px ${y}px`;return dropShadowStyle.blur>0?`text-shadow: ${position} ${dropShadowStyle.blur}px ${color}`:`text-shadow: ${position} ${color}`}function strokeToCSS(stroke){return[`-webkit-text-stroke-width: ${stroke.width}px`,`-webkit-text-stroke-color: ${Color.shared.setValue(stroke.color).toHex()}`,`text-stroke-width: ${stroke.width}px`,`text-stroke-color: ${Color.shared.setValue(stroke.color).toHex()}`,"paint-order: stroke"].join(";")}const templates={fontSize:"font-size: {{VALUE}}px",fontFamily:"font-family: {{VALUE}}",fontWeight:"font-weight: {{VALUE}}",fontStyle:"font-style: {{VALUE}}",fontVariant:"font-variant: {{VALUE}}",letterSpacing:"letter-spacing: {{VALUE}}px",align:"text-align: {{VALUE}}",padding:"padding: {{VALUE}}px",whiteSpace:"white-space: {{VALUE}}",lineHeight:"line-height: {{VALUE}}px",wordWrapWidth:"max-width: {{VALUE}}px"},transform={fill:value=>`color: ${Color.shared.setValue(value).toHex()}`,breakWords:value=>`word-wrap: ${value?"break-all":"break-word"}`,stroke:strokeToCSS,dropShadow:dropShadowToCSS};function tagStyleToCSS(tagStyles,out){for(const i in tagStyles){const tagStyle=tagStyles[i],cssTagStyle=[];for(const j in tagStyle)transform[j]?cssTagStyle.push(transform[j](tagStyle[j])):templates[j]&&cssTagStyle.push(templates[j].replace("{{VALUE}}",tagStyle[j]));out.push(`${i} { ${cssTagStyle.join(";")} }`)}}class HTMLTextStyle extends TextStyle{constructor(options={}){super(options),this._cssOverrides=[],this.cssOverrides=options.cssOverrides??[],this.tagStyles=options.tagStyles??{}}set cssOverrides(value){this._cssOverrides=value instanceof Array?value:[value],this.update()}get cssOverrides(){return this._cssOverrides}update(){this._cssStyle=null,super.update()}clone(){return new HTMLTextStyle({align:this.align,breakWords:this.breakWords,dropShadow:this.dropShadow?{...this.dropShadow}:null,fill:this._fill,fontFamily:this.fontFamily,fontSize:this.fontSize,fontStyle:this.fontStyle,fontVariant:this.fontVariant,fontWeight:this.fontWeight,letterSpacing:this.letterSpacing,lineHeight:this.lineHeight,padding:this.padding,stroke:this._stroke,whiteSpace:this.whiteSpace,wordWrap:this.wordWrap,wordWrapWidth:this.wordWrapWidth,cssOverrides:this.cssOverrides,tagStyles:{...this.tagStyles}})}get cssStyle(){return this._cssStyle||(this._cssStyle=textStyleToCSS(this)),this._cssStyle}addOverride(...value){const toAdd=value.filter(v=>!this.cssOverrides.includes(v));toAdd.length>0&&(this.cssOverrides.push(...toAdd),this.update())}removeOverride(...value){const toRemove=value.filter(v=>this.cssOverrides.includes(v));toRemove.length>0&&(this.cssOverrides=this.cssOverrides.filter(v=>!toRemove.includes(v)),this.update())}set fill(value){typeof value!="string"&&typeof value!="number"&&warn("[HTMLTextStyle] only color fill is not supported by HTMLText"),super.fill=value}set stroke(value){value&&typeof value!="string"&&typeof value!="number"&&warn("[HTMLTextStyle] only color stroke is not supported by HTMLText"),super.stroke=value}}const nssvg="http://www.w3.org/2000/svg",nsxhtml="http://www.w3.org/1999/xhtml";class HTMLTextRenderData{constructor(){this.svgRoot=document.createElementNS(nssvg,"svg"),this.foreignObject=document.createElementNS(nssvg,"foreignObject"),this.domElement=document.createElementNS(nsxhtml,"div"),this.styleElement=document.createElementNS(nsxhtml,"style"),this.image=new Image;const{foreignObject,svgRoot,styleElement,domElement}=this;foreignObject.setAttribute("width","10000"),foreignObject.setAttribute("height","10000"),foreignObject.style.overflow="hidden",svgRoot.appendChild(foreignObject),foreignObject.appendChild(styleElement),foreignObject.appendChild(domElement)}}let tempHTMLTextRenderData;function measureHtmlText(text,style,fontStyleCSS,htmlTextRenderData){htmlTextRenderData||(htmlTextRenderData=tempHTMLTextRenderData||(tempHTMLTextRenderData=new HTMLTextRenderData));const{domElement,styleElement,svgRoot}=htmlTextRenderData;domElement.innerHTML=`<style>${style.cssStyle};</style><div style='padding:0'>${text}</div>`,domElement.setAttribute("style","transform-origin: top left; display: inline-block"),fontStyleCSS&&(styleElement.textContent=fontStyleCSS),document.body.appendChild(svgRoot);const contentBounds=domElement.getBoundingClientRect();svgRoot.remove();const doublePadding=style.padding*2;return{width:contentBounds.width-doublePadding,height:contentBounds.height-doublePadding}}class GraphicsGpuData{constructor(){this.batches=[],this.batched=!1}destroy(){this.batches.forEach(batch=>{BigPool.return(batch)}),this.batches.length=0}}class GraphicsPipe{constructor(renderer,adaptor){this.state=State.for2d(),this.renderer=renderer,this._adaptor=adaptor,this.renderer.runners.contextChange.add(this)}contextChange(){this._adaptor.contextChange(this.renderer)}validateRenderable(graphics){const context=graphics.context,wasBatched=!!graphics._gpuData,gpuContext=this.renderer.graphicsContext.updateGpuContext(context);return!!(gpuContext.isBatchable||wasBatched!==gpuContext.isBatchable)}addRenderable(graphics,instructionSet){const gpuContext=this.renderer.graphicsContext.updateGpuContext(graphics.context);graphics.didViewUpdate&&this._rebuild(graphics),gpuContext.isBatchable?this._addToBatcher(graphics,instructionSet):(this.renderer.renderPipes.batch.break(instructionSet),instructionSet.add(graphics))}updateRenderable(graphics){const batches=this._getGpuDataForRenderable(graphics).batches;for(let i=0;i<batches.length;i++){const batch=batches[i];batch._batcher.updateElement(batch)}}execute(graphics){if(!graphics.isRenderable)return;const renderer=this.renderer,context=graphics.context;if(!renderer.graphicsContext.getGpuContext(context).batches.length)return;const shader=context.customShader||this._adaptor.shader;this.state.blendMode=graphics.groupBlendMode;const localUniforms=shader.resources.localUniforms.uniforms;localUniforms.uTransformMatrix=graphics.groupTransform,localUniforms.uRound=renderer._roundPixels|graphics._roundPixels,color32BitToUniform(graphics.groupColorAlpha,localUniforms.uColor,0),this._adaptor.execute(this,graphics)}_rebuild(graphics){const gpuData=this._getGpuDataForRenderable(graphics),gpuContext=this.renderer.graphicsContext.updateGpuContext(graphics.context);gpuData.destroy(),gpuContext.isBatchable&&this._updateBatchesForRenderable(graphics,gpuData)}_addToBatcher(graphics,instructionSet){const batchPipe=this.renderer.renderPipes.batch,batches=this._getGpuDataForRenderable(graphics).batches;for(let i=0;i<batches.length;i++){const batch=batches[i];batchPipe.addToBatch(batch,instructionSet)}}_getGpuDataForRenderable(graphics){return graphics._gpuData[this.renderer.uid]||this._initGpuDataForRenderable(graphics)}_initGpuDataForRenderable(graphics){const gpuData=new GraphicsGpuData;return graphics._gpuData[this.renderer.uid]=gpuData,gpuData}_updateBatchesForRenderable(graphics,gpuData){const context=graphics.context,gpuContext=this.renderer.graphicsContext.getGpuContext(context),roundPixels=this.renderer._roundPixels|graphics._roundPixels;gpuData.batches=gpuContext.batches.map(batch=>{const batchClone=BigPool.get(BatchableGraphics);return batch.copyTo(batchClone),batchClone.renderable=graphics,batchClone.roundPixels=roundPixels,batchClone})}destroy(){this.renderer=null,this._adaptor.destroy(),this._adaptor=null,this.state=null}}GraphicsPipe.extension={type:[ExtensionType.WebGLPipes,ExtensionType.WebGPUPipes,ExtensionType.CanvasPipes],name:"graphics"};const _PlaneGeometry=class _PlaneGeometry2 extends MeshGeometry{constructor(...args){super({});let options=args[0]??{};typeof options=="number"&&(deprecation(v8_0_0,"PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead"),options={width:options,height:args[1],verticesX:args[2],verticesY:args[3]}),this.build(options)}build(options){options={..._PlaneGeometry2.defaultOptions,...options},this.verticesX=this.verticesX??options.verticesX,this.verticesY=this.verticesY??options.verticesY,this.width=this.width??options.width,this.height=this.height??options.height;const total=this.verticesX*this.verticesY,verts=[],uvs=[],indices=[],verticesX=this.verticesX-1,verticesY=this.verticesY-1,sizeX=this.width/verticesX,sizeY=this.height/verticesY;for(let i=0;i<total;i++){const x=i%this.verticesX,y=i/this.verticesX|0;verts.push(x*sizeX,y*sizeY),uvs.push(x/verticesX,y/verticesY)}const totalSub=verticesX*verticesY;for(let i=0;i<totalSub;i++){const xpos=i%verticesX,ypos=i/verticesX|0,value=ypos*this.verticesX+xpos,value2=ypos*this.verticesX+xpos+1,value3=(ypos+1)*this.verticesX+xpos,value4=(ypos+1)*this.verticesX+xpos+1;indices.push(value,value2,value3,value2,value4,value3)}this.buffers[0].data=new Float32Array(verts),this.buffers[1].data=new Float32Array(uvs),this.indexBuffer.data=new Uint32Array(indices),this.buffers[0].update(),this.buffers[1].update(),this.indexBuffer.update()}};_PlaneGeometry.defaultOptions={width:100,height:100,verticesX:10,verticesY:10};let PlaneGeometry=_PlaneGeometry;class BatchableMesh{constructor(){this.batcherName="default",this.packAsQuad=!1,this.indexOffset=0,this.attributeOffset=0,this.roundPixels=0,this._batcher=null,this._batch=null,this._textureMatrixUpdateId=-1,this._uvUpdateId=-1}get blendMode(){return this.renderable.groupBlendMode}get topology(){return this._topology||this.geometry.topology}set topology(value){this._topology=value}reset(){this.renderable=null,this.texture=null,this._batcher=null,this._batch=null,this.geometry=null,this._uvUpdateId=-1,this._textureMatrixUpdateId=-1}setTexture(value){this.texture!==value&&(this.texture=value,this._textureMatrixUpdateId=-1)}get uvs(){const uvBuffer=this.geometry.getBuffer("aUV"),uvs=uvBuffer.data;let transformedUvs=uvs;const textureMatrix=this.texture.textureMatrix;return textureMatrix.isSimple||(transformedUvs=this._transformedUvs,(this._textureMatrixUpdateId!==textureMatrix._updateID||this._uvUpdateId!==uvBuffer._updateID)&&((!transformedUvs||transformedUvs.length<uvs.length)&&(transformedUvs=this._transformedUvs=new Float32Array(uvs.length)),this._textureMatrixUpdateId=textureMatrix._updateID,this._uvUpdateId=uvBuffer._updateID,textureMatrix.multiplyUvs(uvs,transformedUvs))),transformedUvs}get positions(){return this.geometry.positions}get indices(){return this.geometry.indices}get color(){return this.renderable.groupColorAlpha}get groupTransform(){return this.renderable.groupTransform}get attributeSize(){return this.geometry.positions.length/2}get indexSize(){return this.geometry.indices.length}}class MeshGpuData{destroy(){}}class MeshPipe{constructor(renderer,adaptor){this.localUniforms=new UniformGroup({uTransformMatrix:{value:new Matrix,type:"mat3x3<f32>"},uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uRound:{value:0,type:"f32"}}),this.localUniformsBindGroup=new BindGroup({0:this.localUniforms}),this.renderer=renderer,this._adaptor=adaptor,this._adaptor.init()}validateRenderable(mesh){const meshData=this._getMeshData(mesh),wasBatched=meshData.batched,isBatched=mesh.batched;if(meshData.batched=isBatched,wasBatched!==isBatched)return!0;if(isBatched){const geometry=mesh._geometry;if(geometry.indices.length!==meshData.indexSize||geometry.positions.length!==meshData.vertexSize)return meshData.indexSize=geometry.indices.length,meshData.vertexSize=geometry.positions.length,!0;const batchableMesh=this._getBatchableMesh(mesh);return batchableMesh.texture.uid!==mesh._texture.uid&&(batchableMesh._textureMatrixUpdateId=-1),!batchableMesh._batcher.checkAndUpdateTexture(batchableMesh,mesh._texture)}return!1}addRenderable(mesh,instructionSet){const batcher=this.renderer.renderPipes.batch,{batched}=this._getMeshData(mesh);if(batched){const gpuBatchableMesh=this._getBatchableMesh(mesh);gpuBatchableMesh.setTexture(mesh._texture),gpuBatchableMesh.geometry=mesh._geometry,batcher.addToBatch(gpuBatchableMesh,instructionSet)}else batcher.break(instructionSet),instructionSet.add(mesh)}updateRenderable(mesh){if(mesh.batched){const gpuBatchableMesh=this._getBatchableMesh(mesh);gpuBatchableMesh.setTexture(mesh._texture),gpuBatchableMesh.geometry=mesh._geometry,gpuBatchableMesh._batcher.updateElement(gpuBatchableMesh)}}execute(mesh){if(!mesh.isRenderable)return;mesh.state.blendMode=getAdjustedBlendModeBlend(mesh.groupBlendMode,mesh.texture._source);const localUniforms=this.localUniforms;localUniforms.uniforms.uTransformMatrix=mesh.groupTransform,localUniforms.uniforms.uRound=this.renderer._roundPixels|mesh._roundPixels,localUniforms.update(),color32BitToUniform(mesh.groupColorAlpha,localUniforms.uniforms.uColor,0),this._adaptor.execute(this,mesh)}_getMeshData(mesh){var _a,_b;return(_a=mesh._gpuData)[_b=this.renderer.uid]||(_a[_b]=new MeshGpuData),mesh._gpuData[this.renderer.uid].meshData||this._initMeshData(mesh)}_initMeshData(mesh){return mesh._gpuData[this.renderer.uid].meshData={batched:mesh.batched,indexSize:mesh._geometry.indices?.length,vertexSize:mesh._geometry.positions?.length},mesh._gpuData[this.renderer.uid].meshData}_getBatchableMesh(mesh){var _a,_b;return(_a=mesh._gpuData)[_b=this.renderer.uid]||(_a[_b]=new MeshGpuData),mesh._gpuData[this.renderer.uid].batchableMesh||this._initBatchableMesh(mesh)}_initBatchableMesh(mesh){const gpuMesh=new BatchableMesh;return gpuMesh.renderable=mesh,gpuMesh.setTexture(mesh._texture),gpuMesh.transform=mesh.groupTransform,gpuMesh.roundPixels=this.renderer._roundPixels|mesh._roundPixels,mesh._gpuData[this.renderer.uid].batchableMesh=gpuMesh,gpuMesh}destroy(){this.localUniforms=null,this.localUniformsBindGroup=null,this._adaptor.destroy(),this._adaptor=null,this.renderer=null}}MeshPipe.extension={type:[ExtensionType.WebGLPipes,ExtensionType.WebGPUPipes,ExtensionType.CanvasPipes],name:"mesh"};class GlParticleContainerAdaptor{execute(particleContainerPipe,container){const state=particleContainerPipe.state,renderer=particleContainerPipe.renderer,shader=container.shader||particleContainerPipe.defaultShader;shader.resources.uTexture=container.texture._source,shader.resources.uniforms=particleContainerPipe.localUniforms;const gl=renderer.gl,buffer=particleContainerPipe.getBuffers(container);renderer.shader.bind(shader),renderer.state.set(state),renderer.geometry.bind(buffer.geometry,shader.glProgram);const glType=buffer.geometry.indexBuffer.data.BYTES_PER_ELEMENT===2?gl.UNSIGNED_SHORT:gl.UNSIGNED_INT;gl.drawElements(gl.TRIANGLES,container.particleChildren.length*6,glType,0)}}class GpuParticleContainerAdaptor{execute(particleContainerPipe,container){const renderer=particleContainerPipe.renderer,shader=container.shader||particleContainerPipe.defaultShader;shader.groups[0]=renderer.renderPipes.uniformBatch.getUniformBindGroup(particleContainerPipe.localUniforms,!0),shader.groups[1]=renderer.texture.getTextureBindGroup(container.texture);const state=particleContainerPipe.state,buffer=particleContainerPipe.getBuffers(container);renderer.encoder.draw({geometry:buffer.geometry,shader:container.shader||particleContainerPipe.defaultShader,state,size:container.particleChildren.length*6})}}function createIndicesForQuads(size,outBuffer=null){const totalIndices=size*6;if(totalIndices>65535?outBuffer||(outBuffer=new Uint32Array(totalIndices)):outBuffer||(outBuffer=new Uint16Array(totalIndices)),outBuffer.length!==totalIndices)throw new Error(`Out buffer length is incorrect, got ${outBuffer.length} and expected ${totalIndices}`);for(let i=0,j=0;i<totalIndices;i+=6,j+=4)outBuffer[i+0]=j+0,outBuffer[i+1]=j+1,outBuffer[i+2]=j+2,outBuffer[i+3]=j+0,outBuffer[i+4]=j+2,outBuffer[i+5]=j+3;return outBuffer}function generateParticleUpdateFunction(properties){return{dynamicUpdate:generateUpdateFunction(properties,!0),staticUpdate:generateUpdateFunction(properties,!1)}}function generateUpdateFunction(properties,dynamic){const funcFragments=[];funcFragments.push(`

        var index = 0;

        for (let i = 0; i < ps.length; ++i)
        {
            const p = ps[i];

            `);let offset=0;for(const i in properties){const property=properties[i];if(dynamic!==property.dynamic)continue;funcFragments.push(`offset = index + ${offset}`),funcFragments.push(property.code);const attributeInfo=getAttributeInfoFromFormat(property.format);offset+=attributeInfo.stride/4}funcFragments.push(`
            index += stride * 4;
        }
    `),funcFragments.unshift(`
        var stride = ${offset};
    `);const functionSource=funcFragments.join(`
`);return new Function("ps","f32v","u32v",functionSource)}class ParticleBuffer{constructor(options){this._size=0,this._generateParticleUpdateCache={};const size=this._size=options.size??1e3,properties=options.properties;let staticVertexSize=0,dynamicVertexSize=0;for(const i in properties){const property=properties[i],attributeInfo=getAttributeInfoFromFormat(property.format);property.dynamic?dynamicVertexSize+=attributeInfo.stride:staticVertexSize+=attributeInfo.stride}this._dynamicStride=dynamicVertexSize/4,this._staticStride=staticVertexSize/4,this.staticAttributeBuffer=new ViewableBuffer(size*4*staticVertexSize),this.dynamicAttributeBuffer=new ViewableBuffer(size*4*dynamicVertexSize),this.indexBuffer=createIndicesForQuads(size);const geometry=new Geometry;let dynamicOffset=0,staticOffset=0;this._staticBuffer=new Buffer({data:new Float32Array(1),label:"static-particle-buffer",shrinkToFit:!1,usage:BufferUsage.VERTEX|BufferUsage.COPY_DST}),this._dynamicBuffer=new Buffer({data:new Float32Array(1),label:"dynamic-particle-buffer",shrinkToFit:!1,usage:BufferUsage.VERTEX|BufferUsage.COPY_DST});for(const i in properties){const property=properties[i],attributeInfo=getAttributeInfoFromFormat(property.format);property.dynamic?(geometry.addAttribute(property.attributeName,{buffer:this._dynamicBuffer,stride:this._dynamicStride*4,offset:dynamicOffset*4,format:property.format}),dynamicOffset+=attributeInfo.size):(geometry.addAttribute(property.attributeName,{buffer:this._staticBuffer,stride:this._staticStride*4,offset:staticOffset*4,format:property.format}),staticOffset+=attributeInfo.size)}geometry.addIndex(this.indexBuffer);const uploadFunction=this.getParticleUpdate(properties);this._dynamicUpload=uploadFunction.dynamicUpdate,this._staticUpload=uploadFunction.staticUpdate,this.geometry=geometry}getParticleUpdate(properties){const key=getParticleSyncKey(properties);return this._generateParticleUpdateCache[key]?this._generateParticleUpdateCache[key]:(this._generateParticleUpdateCache[key]=this.generateParticleUpdate(properties),this._generateParticleUpdateCache[key])}generateParticleUpdate(properties){return generateParticleUpdateFunction(properties)}update(particles,uploadStatic){particles.length>this._size&&(uploadStatic=!0,this._size=Math.max(particles.length,this._size*1.5|0),this.staticAttributeBuffer=new ViewableBuffer(this._size*this._staticStride*4*4),this.dynamicAttributeBuffer=new ViewableBuffer(this._size*this._dynamicStride*4*4),this.indexBuffer=createIndicesForQuads(this._size),this.geometry.indexBuffer.setDataWithSize(this.indexBuffer,this.indexBuffer.byteLength,!0));const dynamicAttributeBuffer=this.dynamicAttributeBuffer;if(this._dynamicUpload(particles,dynamicAttributeBuffer.float32View,dynamicAttributeBuffer.uint32View),this._dynamicBuffer.setDataWithSize(this.dynamicAttributeBuffer.float32View,particles.length*this._dynamicStride*4,!0),uploadStatic){const staticAttributeBuffer=this.staticAttributeBuffer;this._staticUpload(particles,staticAttributeBuffer.float32View,staticAttributeBuffer.uint32View),this._staticBuffer.setDataWithSize(staticAttributeBuffer.float32View,particles.length*this._staticStride*4,!0)}}destroy(){this._staticBuffer.destroy(),this._dynamicBuffer.destroy(),this.geometry.destroy()}}function getParticleSyncKey(properties){const keyGen=[];for(const key in properties){const property=properties[key];keyGen.push(key,property.code,property.dynamic?"d":"s")}return keyGen.join("_")}var fragment=`varying vec2 vUV;
varying vec4 vColor;

uniform sampler2D uTexture;

void main(void){
    vec4 color = texture2D(uTexture, vUV) * vColor;
    gl_FragColor = color;
}`,vertex=`attribute vec2 aVertex;
attribute vec2 aUV;
attribute vec4 aColor;

attribute vec2 aPosition;
attribute float aRotation;

uniform mat3 uTranslationMatrix;
uniform float uRound;
uniform vec2 uResolution;
uniform vec4 uColor;

varying vec2 vUV;
varying vec4 vColor;

vec2 roundPixels(vec2 position, vec2 targetSize)
{       
    return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
}

void main(void){
    float cosRotation = cos(aRotation);
    float sinRotation = sin(aRotation);
    float x = aVertex.x * cosRotation - aVertex.y * sinRotation;
    float y = aVertex.x * sinRotation + aVertex.y * cosRotation;

    vec2 v = vec2(x, y);
    v = v + aPosition;

    gl_Position = vec4((uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);

    if(uRound == 1.0)
    {
        gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
    }

    vUV = aUV;
    vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uColor;
}
`,wgsl=`
struct ParticleUniforms {
  uProjectionMatrix:mat3x3<f32>,
  uColor:vec4<f32>,
  uResolution:vec2<f32>,
  uRoundPixels:f32,
};

@group(0) @binding(0) var<uniform> uniforms: ParticleUniforms;

@group(1) @binding(0) var uTexture: texture_2d<f32>;
@group(1) @binding(1) var uSampler : sampler;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>,
    @location(1) color : vec4<f32>,
  };
@vertex
fn mainVertex(
  @location(0) aVertex: vec2<f32>,
  @location(1) aPosition: vec2<f32>,
  @location(2) aUV: vec2<f32>,
  @location(3) aColor: vec4<f32>,
  @location(4) aRotation: f32,
) -> VSOutput {
  
   let v = vec2(
       aVertex.x * cos(aRotation) - aVertex.y * sin(aRotation),
       aVertex.x * sin(aRotation) + aVertex.y * cos(aRotation)
   ) + aPosition;

   let position = vec4((uniforms.uProjectionMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);

    let vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uniforms.uColor;

  return VSOutput(
   position,
   aUV,
   vColor,
  );
}

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @location(1) color: vec4<f32>,
  @builtin(position) position: vec4<f32>,
) -> @location(0) vec4<f32> {

    var sample = textureSample(uTexture, uSampler, uv) * color;
   
    return sample;
}`;class ParticleShader extends Shader{constructor(){const glProgram2=GlProgram.from({vertex,fragment}),gpuProgram2=GpuProgram.from({fragment:{source:wgsl,entryPoint:"mainFragment"},vertex:{source:wgsl,entryPoint:"mainVertex"}});super({glProgram:glProgram2,gpuProgram:gpuProgram2,resources:{uTexture:Texture.WHITE.source,uSampler:new TextureStyle({}),uniforms:{uTranslationMatrix:{value:new Matrix,type:"mat3x3<f32>"},uColor:{value:new Color(16777215),type:"vec4<f32>"},uRound:{value:1,type:"f32"},uResolution:{value:[0,0],type:"vec2<f32>"}}}})}}class ParticleContainerPipe{constructor(renderer,adaptor){this.state=State.for2d(),this.localUniforms=new UniformGroup({uTranslationMatrix:{value:new Matrix,type:"mat3x3<f32>"},uColor:{value:new Float32Array(4),type:"vec4<f32>"},uRound:{value:1,type:"f32"},uResolution:{value:[0,0],type:"vec2<f32>"}}),this.renderer=renderer,this.adaptor=adaptor,this.defaultShader=new ParticleShader,this.state=State.for2d()}validateRenderable(_renderable){return!1}addRenderable(renderable,instructionSet){this.renderer.renderPipes.batch.break(instructionSet),instructionSet.add(renderable)}getBuffers(renderable){return renderable._gpuData[this.renderer.uid]||this._initBuffer(renderable)}_initBuffer(renderable){return renderable._gpuData[this.renderer.uid]=new ParticleBuffer({size:renderable.particleChildren.length,properties:renderable._properties}),renderable._gpuData[this.renderer.uid]}updateRenderable(_renderable){}execute(container){const children=container.particleChildren;if(children.length===0)return;const renderer=this.renderer,buffer=this.getBuffers(container);container.texture||(container.texture=children[0].texture);const state=this.state;buffer.update(children,container._childrenDirty),container._childrenDirty=!1,state.blendMode=getAdjustedBlendModeBlend(container.blendMode,container.texture._source);const uniforms=this.localUniforms.uniforms,transformationMatrix=uniforms.uTranslationMatrix;container.worldTransform.copyTo(transformationMatrix),transformationMatrix.prepend(renderer.globalUniforms.globalUniformData.projectionMatrix),uniforms.uResolution=renderer.globalUniforms.globalUniformData.resolution,uniforms.uRound=renderer._roundPixels|container._roundPixels,color32BitToUniform(container.groupColorAlpha,uniforms.uColor,0),this.adaptor.execute(this,container)}destroy(){this.defaultShader&&(this.defaultShader.destroy(),this.defaultShader=null)}}class GlParticleContainerPipe extends ParticleContainerPipe{constructor(renderer){super(renderer,new GlParticleContainerAdaptor)}}GlParticleContainerPipe.extension={type:[ExtensionType.WebGLPipes],name:"particle"};class GpuParticleContainerPipe extends ParticleContainerPipe{constructor(renderer){super(renderer,new GpuParticleContainerAdaptor)}}GpuParticleContainerPipe.extension={type:[ExtensionType.WebGPUPipes],name:"particle"};const _NineSliceGeometry=class _NineSliceGeometry2 extends PlaneGeometry{constructor(options={}){options={..._NineSliceGeometry2.defaultOptions,...options},super({width:options.width,height:options.height,verticesX:4,verticesY:4}),this.update(options)}update(options){this.width=options.width??this.width,this.height=options.height??this.height,this._originalWidth=options.originalWidth??this._originalWidth,this._originalHeight=options.originalHeight??this._originalHeight,this._leftWidth=options.leftWidth??this._leftWidth,this._rightWidth=options.rightWidth??this._rightWidth,this._topHeight=options.topHeight??this._topHeight,this._bottomHeight=options.bottomHeight??this._bottomHeight,this._anchorX=options.anchor?.x,this._anchorY=options.anchor?.y,this.updateUvs(),this.updatePositions()}updatePositions(){const p=this.positions,{width,height,_leftWidth,_rightWidth,_topHeight,_bottomHeight,_anchorX,_anchorY}=this,w=_leftWidth+_rightWidth,scaleW=width>w?1:width/w,h=_topHeight+_bottomHeight,scaleH=height>h?1:height/h,scale=Math.min(scaleW,scaleH),anchorOffsetX=_anchorX*width,anchorOffsetY=_anchorY*height;p[0]=p[8]=p[16]=p[24]=-anchorOffsetX,p[2]=p[10]=p[18]=p[26]=_leftWidth*scale-anchorOffsetX,p[4]=p[12]=p[20]=p[28]=width-_rightWidth*scale-anchorOffsetX,p[6]=p[14]=p[22]=p[30]=width-anchorOffsetX,p[1]=p[3]=p[5]=p[7]=-anchorOffsetY,p[9]=p[11]=p[13]=p[15]=_topHeight*scale-anchorOffsetY,p[17]=p[19]=p[21]=p[23]=height-_bottomHeight*scale-anchorOffsetY,p[25]=p[27]=p[29]=p[31]=height-anchorOffsetY,this.getBuffer("aPosition").update()}updateUvs(){const uvs=this.uvs;uvs[0]=uvs[8]=uvs[16]=uvs[24]=0,uvs[1]=uvs[3]=uvs[5]=uvs[7]=0,uvs[6]=uvs[14]=uvs[22]=uvs[30]=1,uvs[25]=uvs[27]=uvs[29]=uvs[31]=1;const _uvw=1/this._originalWidth,_uvh=1/this._originalHeight;uvs[2]=uvs[10]=uvs[18]=uvs[26]=_uvw*this._leftWidth,uvs[9]=uvs[11]=uvs[13]=uvs[15]=_uvh*this._topHeight,uvs[4]=uvs[12]=uvs[20]=uvs[28]=1-_uvw*this._rightWidth,uvs[17]=uvs[19]=uvs[21]=uvs[23]=1-_uvh*this._bottomHeight,this.getBuffer("aUV").update()}};_NineSliceGeometry.defaultOptions={width:100,height:100,leftWidth:10,topHeight:10,rightWidth:10,bottomHeight:10,originalWidth:100,originalHeight:100};let NineSliceGeometry=_NineSliceGeometry;class NineSliceSpriteGpuData extends BatchableMesh{constructor(){super(),this.geometry=new NineSliceGeometry}destroy(){this.geometry.destroy()}}class NineSliceSpritePipe{constructor(renderer){this._renderer=renderer}addRenderable(sprite,instructionSet){const gpuSprite=this._getGpuSprite(sprite);sprite.didViewUpdate&&this._updateBatchableSprite(sprite,gpuSprite),this._renderer.renderPipes.batch.addToBatch(gpuSprite,instructionSet)}updateRenderable(sprite){const gpuSprite=this._getGpuSprite(sprite);sprite.didViewUpdate&&this._updateBatchableSprite(sprite,gpuSprite),gpuSprite._batcher.updateElement(gpuSprite)}validateRenderable(sprite){const gpuSprite=this._getGpuSprite(sprite);return!gpuSprite._batcher.checkAndUpdateTexture(gpuSprite,sprite._texture)}_updateBatchableSprite(sprite,batchableSprite){batchableSprite.geometry.update(sprite),batchableSprite.setTexture(sprite._texture)}_getGpuSprite(sprite){return sprite._gpuData[this._renderer.uid]||this._initGPUSprite(sprite)}_initGPUSprite(sprite){const gpuData=sprite._gpuData[this._renderer.uid]=new NineSliceSpriteGpuData,batchableMesh=gpuData;return batchableMesh.renderable=sprite,batchableMesh.transform=sprite.groupTransform,batchableMesh.texture=sprite._texture,batchableMesh.roundPixels=this._renderer._roundPixels|sprite._roundPixels,sprite.didViewUpdate||this._updateBatchableSprite(sprite,batchableMesh),gpuData}destroy(){this._renderer=null}}NineSliceSpritePipe.extension={type:[ExtensionType.WebGLPipes,ExtensionType.WebGPUPipes,ExtensionType.CanvasPipes],name:"nineSliceSprite"};const tilingBit={name:"tiling-bit",vertex:{header:`
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `,main:`
            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;

            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;
        `},fragment:{header:`
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `,main:`

            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);
            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;
            var unclamped = coord;
            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);

            var bias = 0.;

            if(unclamped.x == coord.x && unclamped.y == coord.y)
            {
                bias = -32.;
            }

            outColor = textureSampleBias(uTexture, uSampler, coord, bias);
        `}},tilingBitGl={name:"tiling-bit",vertex:{header:`
            uniform mat3 uTextureTransform;
            uniform vec4 uSizeAnchor;

        `,main:`
            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;

            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;
        `},fragment:{header:`
            uniform sampler2D uTexture;
            uniform mat3 uMapCoord;
            uniform vec4 uClampFrame;
            uniform vec2 uClampOffset;
        `,main:`

        vec2 coord = vUV + ceil(uClampOffset - vUV);
        coord = (uMapCoord * vec3(coord, 1.0)).xy;
        vec2 unclamped = coord;
        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);

        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0

        `}};let gpuProgram$1,glProgram$1;class TilingSpriteShader extends Shader{constructor(){gpuProgram$1??(gpuProgram$1=compileHighShaderGpuProgram({name:"tiling-sprite-shader",bits:[localUniformBit,tilingBit,roundPixelsBit]})),glProgram$1??(glProgram$1=compileHighShaderGlProgram({name:"tiling-sprite-shader",bits:[localUniformBitGl,tilingBitGl,roundPixelsBitGl]}));const tilingUniforms=new UniformGroup({uMapCoord:{value:new Matrix,type:"mat3x3<f32>"},uClampFrame:{value:new Float32Array([0,0,1,1]),type:"vec4<f32>"},uClampOffset:{value:new Float32Array([0,0]),type:"vec2<f32>"},uTextureTransform:{value:new Matrix,type:"mat3x3<f32>"},uSizeAnchor:{value:new Float32Array([100,100,.5,.5]),type:"vec4<f32>"}});super({glProgram:glProgram$1,gpuProgram:gpuProgram$1,resources:{localUniforms:new UniformGroup({uTransformMatrix:{value:new Matrix,type:"mat3x3<f32>"},uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uRound:{value:0,type:"f32"}}),tilingUniforms,uTexture:Texture.EMPTY.source,uSampler:Texture.EMPTY.source.style}})}updateUniforms(width,height,matrix,anchorX,anchorY,texture){const tilingUniforms=this.resources.tilingUniforms,textureWidth=texture.width,textureHeight=texture.height,textureMatrix=texture.textureMatrix,uTextureTransform=tilingUniforms.uniforms.uTextureTransform;uTextureTransform.set(matrix.a*textureWidth/width,matrix.b*textureWidth/height,matrix.c*textureHeight/width,matrix.d*textureHeight/height,matrix.tx/width,matrix.ty/height),uTextureTransform.invert(),tilingUniforms.uniforms.uMapCoord=textureMatrix.mapCoord,tilingUniforms.uniforms.uClampFrame=textureMatrix.uClampFrame,tilingUniforms.uniforms.uClampOffset=textureMatrix.uClampOffset,tilingUniforms.uniforms.uTextureTransform=uTextureTransform,tilingUniforms.uniforms.uSizeAnchor[0]=width,tilingUniforms.uniforms.uSizeAnchor[1]=height,tilingUniforms.uniforms.uSizeAnchor[2]=anchorX,tilingUniforms.uniforms.uSizeAnchor[3]=anchorY,texture&&(this.resources.uTexture=texture.source,this.resources.uSampler=texture.source.style)}}class QuadGeometry extends MeshGeometry{constructor(){super({positions:new Float32Array([0,0,1,0,1,1,0,1]),uvs:new Float32Array([0,0,1,0,1,1,0,1]),indices:new Uint32Array([0,1,2,0,2,3])})}}function setPositions(tilingSprite,positions){const anchorX=tilingSprite.anchor.x,anchorY=tilingSprite.anchor.y;positions[0]=-anchorX*tilingSprite.width,positions[1]=-anchorY*tilingSprite.height,positions[2]=(1-anchorX)*tilingSprite.width,positions[3]=-anchorY*tilingSprite.height,positions[4]=(1-anchorX)*tilingSprite.width,positions[5]=(1-anchorY)*tilingSprite.height,positions[6]=-anchorX*tilingSprite.width,positions[7]=(1-anchorY)*tilingSprite.height}function applyMatrix(array,stride,offset,matrix){let index=0;const size=array.length/stride,a=matrix.a,b=matrix.b,c=matrix.c,d=matrix.d,tx=matrix.tx,ty=matrix.ty;for(offset*=stride;index<size;){const x=array[offset],y=array[offset+1];array[offset]=a*x+c*y+tx,array[offset+1]=b*x+d*y+ty,offset+=stride,index++}}function setUvs(tilingSprite,uvs){const texture=tilingSprite.texture,width=texture.frame.width,height=texture.frame.height;let anchorX=0,anchorY=0;tilingSprite.applyAnchorToTexture&&(anchorX=tilingSprite.anchor.x,anchorY=tilingSprite.anchor.y),uvs[0]=uvs[6]=-anchorX,uvs[2]=uvs[4]=1-anchorX,uvs[1]=uvs[3]=-anchorY,uvs[5]=uvs[7]=1-anchorY;const textureMatrix=Matrix.shared;textureMatrix.copyFrom(tilingSprite._tileTransform.matrix),textureMatrix.tx/=tilingSprite.width,textureMatrix.ty/=tilingSprite.height,textureMatrix.invert(),textureMatrix.scale(tilingSprite.width/width,tilingSprite.height/height),applyMatrix(uvs,2,0,textureMatrix)}const sharedQuad=new QuadGeometry;class TilingSpriteGpuData{constructor(){this.canBatch=!0,this.geometry=new MeshGeometry({indices:sharedQuad.indices.slice(),positions:sharedQuad.positions.slice(),uvs:sharedQuad.uvs.slice()})}destroy(){this.geometry.destroy(),this.shader?.destroy()}}class TilingSpritePipe{constructor(renderer){this._state=State.default2d,this._renderer=renderer}validateRenderable(renderable){const tilingSpriteData=this._getTilingSpriteData(renderable),couldBatch=tilingSpriteData.canBatch;this._updateCanBatch(renderable);const canBatch=tilingSpriteData.canBatch;if(canBatch&&canBatch===couldBatch){const{batchableMesh}=tilingSpriteData;return!batchableMesh._batcher.checkAndUpdateTexture(batchableMesh,renderable.texture)}return couldBatch!==canBatch}addRenderable(tilingSprite,instructionSet){const batcher=this._renderer.renderPipes.batch;this._updateCanBatch(tilingSprite);const tilingSpriteData=this._getTilingSpriteData(tilingSprite),{geometry,canBatch}=tilingSpriteData;if(canBatch){tilingSpriteData.batchableMesh||(tilingSpriteData.batchableMesh=new BatchableMesh);const batchableMesh=tilingSpriteData.batchableMesh;tilingSprite.didViewUpdate&&(this._updateBatchableMesh(tilingSprite),batchableMesh.geometry=geometry,batchableMesh.renderable=tilingSprite,batchableMesh.transform=tilingSprite.groupTransform,batchableMesh.setTexture(tilingSprite._texture)),batchableMesh.roundPixels=this._renderer._roundPixels|tilingSprite._roundPixels,batcher.addToBatch(batchableMesh,instructionSet)}else batcher.break(instructionSet),tilingSpriteData.shader||(tilingSpriteData.shader=new TilingSpriteShader),this.updateRenderable(tilingSprite),instructionSet.add(tilingSprite)}execute(tilingSprite){const{shader}=this._getTilingSpriteData(tilingSprite);shader.groups[0]=this._renderer.globalUniforms.bindGroup;const localUniforms=shader.resources.localUniforms.uniforms;localUniforms.uTransformMatrix=tilingSprite.groupTransform,localUniforms.uRound=this._renderer._roundPixels|tilingSprite._roundPixels,color32BitToUniform(tilingSprite.groupColorAlpha,localUniforms.uColor,0),this._state.blendMode=getAdjustedBlendModeBlend(tilingSprite.groupBlendMode,tilingSprite.texture._source),this._renderer.encoder.draw({geometry:sharedQuad,shader,state:this._state})}updateRenderable(tilingSprite){const tilingSpriteData=this._getTilingSpriteData(tilingSprite),{canBatch}=tilingSpriteData;if(canBatch){const{batchableMesh}=tilingSpriteData;tilingSprite.didViewUpdate&&this._updateBatchableMesh(tilingSprite),batchableMesh._batcher.updateElement(batchableMesh)}else if(tilingSprite.didViewUpdate){const{shader}=tilingSpriteData;shader.updateUniforms(tilingSprite.width,tilingSprite.height,tilingSprite._tileTransform.matrix,tilingSprite.anchor.x,tilingSprite.anchor.y,tilingSprite.texture)}}_getTilingSpriteData(renderable){return renderable._gpuData[this._renderer.uid]||this._initTilingSpriteData(renderable)}_initTilingSpriteData(tilingSprite){const gpuData=new TilingSpriteGpuData;return gpuData.renderable=tilingSprite,tilingSprite._gpuData[this._renderer.uid]=gpuData,gpuData}_updateBatchableMesh(tilingSprite){const renderableData=this._getTilingSpriteData(tilingSprite),{geometry}=renderableData,style=tilingSprite.texture.source.style;style.addressMode!=="repeat"&&(style.addressMode="repeat",style.update()),setUvs(tilingSprite,geometry.uvs),setPositions(tilingSprite,geometry.positions)}destroy(){this._renderer=null}_updateCanBatch(tilingSprite){const renderableData=this._getTilingSpriteData(tilingSprite),texture=tilingSprite.texture;let _nonPowOf2wrapping=!0;return this._renderer.type===RendererType.WEBGL&&(_nonPowOf2wrapping=this._renderer.context.supports.nonPowOf2wrapping),renderableData.canBatch=texture.textureMatrix.isSimple&&(_nonPowOf2wrapping||texture.source.isPowerOfTwo),renderableData.canBatch}}TilingSpritePipe.extension={type:[ExtensionType.WebGLPipes,ExtensionType.WebGPUPipes,ExtensionType.CanvasPipes],name:"tilingSprite"};const localUniformMSDFBit={name:"local-uniform-msdf-bit",vertex:{header:`
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32,
                uRound:f32,
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `,main:`
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `,end:`
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `},fragment:{header:`
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
         `,main:`
            outColor = vec4<f32>(calculateMSDFAlpha(outColor, localUniforms.uColor, localUniforms.uDistance));
        `}},localUniformMSDFBitGl={name:"local-uniform-msdf-bit",vertex:{header:`
            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `,main:`
            vColor *= uColor;
            modelMatrix *= uTransformMatrix;
        `,end:`
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `},fragment:{header:`
            uniform float uDistance;
         `,main:`
            outColor = vec4(calculateMSDFAlpha(outColor, vColor, uDistance));
        `}},mSDFBit={name:"msdf-bit",fragment:{header:`
            fn calculateMSDFAlpha(msdfColor:vec4<f32>, shapeColor:vec4<f32>, distance:f32) -> f32 {

                // MSDF
                var median = msdfColor.r + msdfColor.g + msdfColor.b -
                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));

                // SDF
                median = min(median, msdfColor.a);

                var screenPxDistance = distance * (median - 0.5);
                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                // Gamma correction for coverage-like alpha
                var luma: f32 = dot(shapeColor.rgb, vec3<f32>(0.299, 0.587, 0.114));
                var gamma: f32 = mix(1.0, 1.0 / 2.2, luma);
                var coverage: f32 = pow(shapeColor.a * alpha, gamma);

                return coverage;

            }
        `}},mSDFBitGl={name:"msdf-bit",fragment:{header:`
            float calculateMSDFAlpha(vec4 msdfColor, vec4 shapeColor, float distance) {

                // MSDF
                float median = msdfColor.r + msdfColor.g + msdfColor.b -
                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));

                // SDF
                median = min(median, msdfColor.a);

                float screenPxDistance = distance * (median - 0.5);
                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);

                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                // Gamma correction for coverage-like alpha
                float luma = dot(shapeColor.rgb, vec3(0.299, 0.587, 0.114));
                float gamma = mix(1.0, 1.0 / 2.2, luma);
                float coverage = pow(shapeColor.a * alpha, gamma);

                return coverage;
            }
        `}};let gpuProgram,glProgram;class SdfShader extends Shader{constructor(maxTextures){const uniforms=new UniformGroup({uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uTransformMatrix:{value:new Matrix,type:"mat3x3<f32>"},uDistance:{value:4,type:"f32"},uRound:{value:0,type:"f32"}});gpuProgram??(gpuProgram=compileHighShaderGpuProgram({name:"sdf-shader",bits:[colorBit,generateTextureBatchBit(maxTextures),localUniformMSDFBit,mSDFBit,roundPixelsBit]})),glProgram??(glProgram=compileHighShaderGlProgram({name:"sdf-shader",bits:[colorBitGl,generateTextureBatchBitGl(maxTextures),localUniformMSDFBitGl,mSDFBitGl,roundPixelsBitGl]})),super({glProgram,gpuProgram,resources:{localUniforms:uniforms,batchSamplers:getBatchSamplersUniformGroup(maxTextures)}})}}class BitmapTextGraphics extends Graphics{destroy(){this.context.customShader&&this.context.customShader.destroy(),super.destroy()}}class BitmapTextPipe{constructor(renderer){this._renderer=renderer,this._renderer.renderableGC.addManagedHash(this,"_gpuBitmapText")}validateRenderable(bitmapText){const graphicsRenderable=this._getGpuBitmapText(bitmapText);return bitmapText._didTextUpdate&&(bitmapText._didTextUpdate=!1,this._updateContext(bitmapText,graphicsRenderable)),this._renderer.renderPipes.graphics.validateRenderable(graphicsRenderable)}addRenderable(bitmapText,instructionSet){const graphicsRenderable=this._getGpuBitmapText(bitmapText);syncWithProxy(bitmapText,graphicsRenderable),bitmapText._didTextUpdate&&(bitmapText._didTextUpdate=!1,this._updateContext(bitmapText,graphicsRenderable)),this._renderer.renderPipes.graphics.addRenderable(graphicsRenderable,instructionSet),graphicsRenderable.context.customShader&&this._updateDistanceField(bitmapText)}updateRenderable(bitmapText){const graphicsRenderable=this._getGpuBitmapText(bitmapText);syncWithProxy(bitmapText,graphicsRenderable),this._renderer.renderPipes.graphics.updateRenderable(graphicsRenderable),graphicsRenderable.context.customShader&&this._updateDistanceField(bitmapText)}_updateContext(bitmapText,proxyGraphics){const{context}=proxyGraphics,bitmapFont=BitmapFontManager.getFont(bitmapText.text,bitmapText._style);context.clear(),bitmapFont.distanceField.type!=="none"&&(context.customShader||(context.customShader=new SdfShader(this._renderer.limits.maxBatchableTextures)));const chars=CanvasTextMetrics.graphemeSegmenter(bitmapText.text),style=bitmapText._style;let currentY=bitmapFont.baseLineOffset;const bitmapTextLayout=getBitmapTextLayout(chars,style,bitmapFont,!0);let index=0;const padding=style.padding,scale=bitmapTextLayout.scale;let tx=bitmapTextLayout.width,ty=bitmapTextLayout.height+bitmapTextLayout.offsetY;style._stroke&&(tx+=style._stroke.width/scale,ty+=style._stroke.width/scale),context.translate(-bitmapText._anchor._x*tx-padding,-bitmapText._anchor._y*ty-padding).scale(scale,scale);const tint=bitmapFont.applyFillAsTint?style._fill.color:16777215;for(let i=0;i<bitmapTextLayout.lines.length;i++){const line=bitmapTextLayout.lines[i];for(let j=0;j<line.charPositions.length;j++){const char=chars[index++],charData=bitmapFont.chars[char];charData?.texture&&context.texture(charData.texture,tint||"black",Math.round(line.charPositions[j]+charData.xOffset),Math.round(currentY+charData.yOffset))}currentY+=bitmapFont.lineHeight}}_getGpuBitmapText(bitmapText){return bitmapText._gpuData[this._renderer.uid]||this.initGpuText(bitmapText)}initGpuText(bitmapText){const proxyRenderable=new BitmapTextGraphics;return bitmapText._gpuData[this._renderer.uid]=proxyRenderable,this._updateContext(bitmapText,proxyRenderable),proxyRenderable}_updateDistanceField(bitmapText){const context=this._getGpuBitmapText(bitmapText).context,fontFamily=bitmapText._style.fontFamily,dynamicFont=Cache.get(`${fontFamily}-bitmap`),{a,b,c,d}=bitmapText.groupTransform,dx=Math.sqrt(a*a+b*b),dy=Math.sqrt(c*c+d*d),worldScale=(Math.abs(dx)+Math.abs(dy))/2,fontScale=dynamicFont.baseRenderedFontSize/bitmapText._style.fontSize,distance=worldScale*dynamicFont.distanceField.range*(1/fontScale);context.customShader.resources.localUniforms.uniforms.uDistance=distance}destroy(){this._renderer=null}}BitmapTextPipe.extension={type:[ExtensionType.WebGLPipes,ExtensionType.WebGPUPipes,ExtensionType.CanvasPipes],name:"bitmapText"};function syncWithProxy(container,proxy){proxy.groupTransform=container.groupTransform,proxy.groupColorAlpha=container.groupColorAlpha,proxy.groupColor=container.groupColor,proxy.groupBlendMode=container.groupBlendMode,proxy.globalDisplayStatus=container.globalDisplayStatus,proxy.groupTransform=container.groupTransform,proxy.localDisplayStatus=container.localDisplayStatus,proxy.groupAlpha=container.groupAlpha,proxy._roundPixels=container._roundPixels}class BatchableHTMLText extends BatchableSprite{constructor(renderer){super(),this.generatingTexture=!1,this._renderer=renderer,renderer.runners.resolutionChange.add(this)}resolutionChange(){const text=this.renderable;text._autoResolution&&text.onViewUpdate()}destroy(){this._renderer.htmlText.returnTexturePromise(this.texturePromise),this.texturePromise=null,this._renderer=null}}function updateTextBounds(batchableSprite,text){const{texture,bounds}=batchableSprite;updateQuadBounds(bounds,text._anchor,texture);const padding=text._style._getFinalPadding();bounds.minX-=padding,bounds.minY-=padding,bounds.maxX-=padding,bounds.maxY-=padding}class HTMLTextPipe{constructor(renderer){this._renderer=renderer}validateRenderable(htmlText){return htmlText._didTextUpdate}addRenderable(htmlText,instructionSet){const batchableHTMLText=this._getGpuText(htmlText);htmlText._didTextUpdate&&(this._updateGpuText(htmlText).catch(e=>{console.error(e)}),htmlText._didTextUpdate=!1,updateTextBounds(batchableHTMLText,htmlText)),this._renderer.renderPipes.batch.addToBatch(batchableHTMLText,instructionSet)}updateRenderable(htmlText){const batchableHTMLText=this._getGpuText(htmlText);batchableHTMLText._batcher.updateElement(batchableHTMLText)}async _updateGpuText(htmlText){htmlText._didTextUpdate=!1;const batchableHTMLText=this._getGpuText(htmlText);if(batchableHTMLText.generatingTexture)return;batchableHTMLText.texturePromise&&(this._renderer.htmlText.returnTexturePromise(batchableHTMLText.texturePromise),batchableHTMLText.texturePromise=null),batchableHTMLText.generatingTexture=!0,htmlText._resolution=htmlText._autoResolution?this._renderer.resolution:htmlText.resolution;const texturePromise=this._renderer.htmlText.getTexturePromise(htmlText);batchableHTMLText.texturePromise=texturePromise,batchableHTMLText.texture=await texturePromise;const renderGroup=htmlText.renderGroup||htmlText.parentRenderGroup;renderGroup&&(renderGroup.structureDidChange=!0),batchableHTMLText.generatingTexture=!1,updateTextBounds(batchableHTMLText,htmlText)}_getGpuText(htmlText){return htmlText._gpuData[this._renderer.uid]||this.initGpuText(htmlText)}initGpuText(htmlText){const batchableHTMLText=new BatchableHTMLText(this._renderer);return batchableHTMLText.renderable=htmlText,batchableHTMLText.transform=htmlText.groupTransform,batchableHTMLText.texture=Texture.EMPTY,batchableHTMLText.bounds={minX:0,maxX:1,minY:0,maxY:0},batchableHTMLText.roundPixels=this._renderer._roundPixels|htmlText._roundPixels,htmlText._resolution=htmlText._autoResolution?this._renderer.resolution:htmlText.resolution,htmlText._gpuData[this._renderer.uid]=batchableHTMLText,batchableHTMLText}destroy(){this._renderer=null}}HTMLTextPipe.extension={type:[ExtensionType.WebGLPipes,ExtensionType.WebGPUPipes,ExtensionType.CanvasPipes],name:"htmlText"};function isSafari(){const{userAgent}=DOMAdapter.get().getNavigator();return/^((?!chrome|android).)*safari/i.test(userAgent)}const tempBounds=new Bounds;function getPo2TextureFromSource(image,width,height,resolution){const bounds=tempBounds;bounds.minX=0,bounds.minY=0,bounds.maxX=image.width/resolution|0,bounds.maxY=image.height/resolution|0;const texture=TexturePool.getOptimalTexture(bounds.width,bounds.height,resolution,!1);return texture.source.uploadMethodId="image",texture.source.resource=image,texture.source.alphaMode="premultiply-alpha-on-upload",texture.frame.width=width/resolution,texture.frame.height=height/resolution,texture.source.emit("update",texture.source),texture.updateUvs(),texture}function extractFontFamilies(text,style){const fontFamily=style.fontFamily,fontFamilies=[],dedupe={},regex=/font-family:([^;"\s]+)/g,matches=text.match(regex);function addFontFamily(fontFamily2){dedupe[fontFamily2]||(fontFamilies.push(fontFamily2),dedupe[fontFamily2]=!0)}if(Array.isArray(fontFamily))for(let i=0;i<fontFamily.length;i++)addFontFamily(fontFamily[i]);else addFontFamily(fontFamily);matches&&matches.forEach(match=>{const fontFamily2=match.split(":")[1].trim();addFontFamily(fontFamily2)});for(const i in style.tagStyles){const fontFamily2=style.tagStyles[i].fontFamily;addFontFamily(fontFamily2)}return fontFamilies}async function loadFontAsBase64(url){const blob=await(await DOMAdapter.get().fetch(url)).blob(),reader=new FileReader;return await new Promise((resolve,reject)=>{reader.onloadend=()=>resolve(reader.result),reader.onerror=reject,reader.readAsDataURL(blob)})}async function loadFontCSS(style,url){const dataSrc=await loadFontAsBase64(url);return`@font-face {
        font-family: "${style.fontFamily}";
        src: url('${dataSrc}');
        font-weight: ${style.fontWeight};
        font-style: ${style.fontStyle};
    }`}const FontStylePromiseCache=new Map;async function getFontCss(fontFamilies,style,defaultOptions){const fontPromises=fontFamilies.filter(fontFamily=>Cache.has(`${fontFamily}-and-url`)).map((fontFamily,i)=>{if(!FontStylePromiseCache.has(fontFamily)){const{url}=Cache.get(`${fontFamily}-and-url`);i===0?FontStylePromiseCache.set(fontFamily,loadFontCSS({fontWeight:style.fontWeight,fontStyle:style.fontStyle,fontFamily},url)):FontStylePromiseCache.set(fontFamily,loadFontCSS({fontWeight:defaultOptions.fontWeight,fontStyle:defaultOptions.fontStyle,fontFamily},url))}return FontStylePromiseCache.get(fontFamily)});return(await Promise.all(fontPromises)).join(`
`)}function getSVGUrl(text,style,resolution,fontCSS,htmlTextData){const{domElement,styleElement,svgRoot}=htmlTextData;domElement.innerHTML=`<style>${style.cssStyle}</style><div style='padding:0;'>${text}</div>`,domElement.setAttribute("style",`transform: scale(${resolution});transform-origin: top left; display: inline-block`),styleElement.textContent=fontCSS;const{width,height}=htmlTextData.image;return svgRoot.setAttribute("width",width.toString()),svgRoot.setAttribute("height",height.toString()),new XMLSerializer().serializeToString(svgRoot)}function getTemporaryCanvasFromImage(image,resolution){const canvasAndContext=CanvasPool.getOptimalCanvasAndContext(image.width,image.height,resolution),{context}=canvasAndContext;return context.clearRect(0,0,image.width,image.height),context.drawImage(image,0,0),canvasAndContext}function loadSVGImage(image,url,delay){return new Promise(async resolve=>{delay&&await new Promise(resolve2=>setTimeout(resolve2,100)),image.onload=()=>{resolve()},image.src=`data:image/svg+xml;charset=utf8,${encodeURIComponent(url)}`,image.crossOrigin="anonymous"})}class HTMLTextSystem{constructor(renderer){this._renderer=renderer,this._createCanvas=renderer.type===RendererType.WEBGPU}getTexture(options){return this.getTexturePromise(options)}getTexturePromise(options){return this._buildTexturePromise(options)}async _buildTexturePromise(options){const{text,style,resolution,textureStyle}=options,htmlTextData=BigPool.get(HTMLTextRenderData),fontFamilies=extractFontFamilies(text,style),fontCSS=await getFontCss(fontFamilies,style,HTMLTextStyle.defaultTextStyle),measured=measureHtmlText(text,style,fontCSS,htmlTextData),width=Math.ceil(Math.ceil(Math.max(1,measured.width)+style.padding*2)*resolution),height=Math.ceil(Math.ceil(Math.max(1,measured.height)+style.padding*2)*resolution),image=htmlTextData.image,uvSafeOffset=2;image.width=(width|0)+uvSafeOffset,image.height=(height|0)+uvSafeOffset;const svgURL=getSVGUrl(text,style,resolution,fontCSS,htmlTextData);await loadSVGImage(image,svgURL,isSafari()&&fontFamilies.length>0);const resource=image;let canvasAndContext;this._createCanvas&&(canvasAndContext=getTemporaryCanvasFromImage(image,resolution));const texture=getPo2TextureFromSource(canvasAndContext?canvasAndContext.canvas:resource,image.width-uvSafeOffset,image.height-uvSafeOffset,resolution);return textureStyle&&(texture.source.style=textureStyle),this._createCanvas&&(this._renderer.texture.initSource(texture.source),CanvasPool.returnCanvasAndContext(canvasAndContext)),BigPool.return(htmlTextData),texture}returnTexturePromise(texturePromise){texturePromise.then(texture=>{this._cleanUp(texture)}).catch(()=>{warn("HTMLTextSystem: Failed to clean texture")})}_cleanUp(texture){TexturePool.returnTexture(texture,!0),texture.source.resource=null,texture.source.uploadMethodId="unknown"}destroy(){this._renderer=null}}HTMLTextSystem.extension={type:[ExtensionType.WebGLSystem,ExtensionType.WebGPUSystem,ExtensionType.CanvasSystem],name:"htmlText"};class BatchableText extends BatchableSprite{constructor(renderer){super(),this._renderer=renderer,renderer.runners.resolutionChange.add(this)}resolutionChange(){const text=this.renderable;text._autoResolution&&text.onViewUpdate()}destroy(){this._renderer.canvasText.returnTexture(this.texture),this._renderer=null}}class CanvasTextPipe{constructor(renderer){this._renderer=renderer}validateRenderable(text){return text._didTextUpdate}addRenderable(text,instructionSet){const batchableText=this._getGpuText(text);text._didTextUpdate&&(this._updateGpuText(text),text._didTextUpdate=!1),this._renderer.renderPipes.batch.addToBatch(batchableText,instructionSet)}updateRenderable(text){const batchableText=this._getGpuText(text);batchableText._batcher.updateElement(batchableText)}_updateGpuText(text){const batchableText=this._getGpuText(text);batchableText.texture&&this._renderer.canvasText.returnTexture(batchableText.texture),text._resolution=text._autoResolution?this._renderer.resolution:text.resolution,batchableText.texture=batchableText.texture=this._renderer.canvasText.getTexture(text),updateTextBounds(batchableText,text)}_getGpuText(text){return text._gpuData[this._renderer.uid]||this.initGpuText(text)}initGpuText(text){const batchableText=new BatchableText(this._renderer);return batchableText.renderable=text,batchableText.transform=text.groupTransform,batchableText.bounds={minX:0,maxX:1,minY:0,maxY:0},batchableText.roundPixels=this._renderer._roundPixels|text._roundPixels,text._gpuData[this._renderer.uid]=batchableText,batchableText}destroy(){this._renderer=null}}CanvasTextPipe.extension={type:[ExtensionType.WebGLPipes,ExtensionType.WebGPUPipes,ExtensionType.CanvasPipes],name:"text"};class CanvasTextSystem{constructor(_renderer){this._renderer=_renderer}getTexture(options,_resolution,_style,_textKey){typeof options=="string"&&(deprecation("8.0.0","CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments"),options={text:options,style:_style,resolution:_resolution}),options.style instanceof TextStyle||(options.style=new TextStyle(options.style)),options.textureStyle instanceof TextureStyle||(options.textureStyle=new TextureStyle(options.textureStyle)),typeof options.text!="string"&&(options.text=options.text.toString());const{text,style,textureStyle}=options,resolution=options.resolution??this._renderer.resolution,{frame,canvasAndContext}=CanvasTextGenerator.getCanvasAndContext({text,style,resolution}),texture=getPo2TextureFromSource(canvasAndContext.canvas,frame.width,frame.height,resolution);if(textureStyle&&(texture.source.style=textureStyle),style.trim&&(frame.pad(style.padding),texture.frame.copyFrom(frame),texture.updateUvs()),style.filters){const filteredTexture=this._applyFilters(texture,style.filters);return this.returnTexture(texture),CanvasTextGenerator.returnCanvasAndContext(canvasAndContext),filteredTexture}return this._renderer.texture.initSource(texture._source),CanvasTextGenerator.returnCanvasAndContext(canvasAndContext),texture}returnTexture(texture){const source=texture.source;source.resource=null,source.uploadMethodId="unknown",source.alphaMode="no-premultiply-alpha",TexturePool.returnTexture(texture,!0)}renderTextToCanvas(){deprecation("8.10.0","CanvasTextSystem.renderTextToCanvas: no longer supported, use CanvasTextSystem.getTexture instead")}_applyFilters(texture,filters){const currentRenderTarget=this._renderer.renderTarget.renderTarget,resultTexture=this._renderer.filter.generateFilteredTexture({texture,filters});return this._renderer.renderTarget.bind(currentRenderTarget,!1),resultTexture}destroy(){this._renderer=null}}CanvasTextSystem.extension={type:[ExtensionType.WebGLSystem,ExtensionType.WebGPUSystem,ExtensionType.CanvasSystem],name:"canvasText"};extensions.add(ResizePlugin);extensions.add(TickerPlugin);extensions.add(GraphicsPipe);extensions.add(GraphicsContextSystem);extensions.add(MeshPipe);extensions.add(GlParticleContainerPipe);extensions.add(GpuParticleContainerPipe);extensions.add(CanvasTextSystem);extensions.add(CanvasTextPipe);extensions.add(BitmapTextPipe);extensions.add(HTMLTextSystem);extensions.add(HTMLTextPipe);extensions.add(TilingSpritePipe);extensions.add(NineSliceSpritePipe);extensions.add(FilterSystem);extensions.add(FilterPipe);
